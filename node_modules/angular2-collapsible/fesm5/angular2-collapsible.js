import { Injectable, Component, Input, ElementRef, HostBinding, Output, EventEmitter, ContentChildren, HostListener, ViewChildren, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { __values } from 'tslib';
import { DomSanitizer } from '@angular/platform-browser';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleService = /** @class */ (function () {
    function CollapsibleService() {
        this.headers = new Array();
        this.bodies = new Array();
    }
    /**
     * @return {?}
     */
    CollapsibleService.prototype.getType = /**
     * @return {?}
     */
    function () {
        return this.type;
    };
    /**
     * @param {?} type
     * @return {?}
     */
    CollapsibleService.prototype.setType = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        this.type = type;
    };
    /**
     * @return {?}
     */
    CollapsibleService.prototype.getCollapsibleTable = /**
     * @return {?}
     */
    function () {
        return this.collapsibleTable;
    };
    /**
     * @param {?} table
     * @return {?}
     */
    CollapsibleService.prototype.setCollapsibleTable = /**
     * @param {?} table
     * @return {?}
     */
    function (table) {
        this.collapsibleTable = table;
    };
    /**
     * @param {?} header
     * @return {?}
     */
    CollapsibleService.prototype.addListHeader = /**
     * @param {?} header
     * @return {?}
     */
    function (header) {
        this.headers.push(header);
    };
    /**
     * @param {?} body
     * @return {?}
     */
    CollapsibleService.prototype.addListBody = /**
     * @param {?} body
     * @return {?}
     */
    function (body) {
        this.bodies.push(body);
    };
    /**
     * @return {?}
     */
    CollapsibleService.prototype.collapseAll = /**
     * @return {?}
     */
    function () {
        this.bodies.forEach(function (collapsibleBodyComponent) {
            // set 'expanded' properties of all the CollapsibleBodyComponents to 'false'
            collapsibleBodyComponent.expanded = false;
            collapsibleBodyComponent.expandedState = collapsibleBodyComponent.expanded.toString();
            // emit 'toggleState' event for all the CollapsibleBodyComponents
            collapsibleBodyComponent.toggleState.emit(false);
        });
    };
    CollapsibleService.decorators = [
        { type: Injectable }
    ];
    return CollapsibleService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleEvent = /** @class */ (function () {
    function CollapsibleEvent() {
    }
    return CollapsibleEvent;
}());
var CollapsibleEventService = /** @class */ (function () {
    function CollapsibleEventService() {
        this.toggleCollapsibleItemSource = new Subject();
        // Observable string streams
        this.toggleCollapsibleItem$ = this.toggleCollapsibleItemSource.asObservable();
    }
    // Toggle collapsible item
    /**
     * @param {?=} event
     * @return {?}
     */
    CollapsibleEventService.prototype.toggleCollapsibleItem = /**
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        this.toggleCollapsibleItemSource.next(event);
    };
    /**
     * @return {?}
     */
    CollapsibleEventService.prototype.unsubscribe = /**
     * @return {?}
     */
    function () {
        this.toggleCollapsibleItemSource.unsubscribe();
    };
    CollapsibleEventService.decorators = [
        { type: Injectable }
    ];
    return CollapsibleEventService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleAnimationsService = /** @class */ (function () {
    function CollapsibleAnimationsService() {
    }
    /**
     * @param {?} triggerName
     * @return {?}
     */
    CollapsibleAnimationsService.collapsibleBodyAnimations = /**
     * @param {?} triggerName
     * @return {?}
     */
    function (triggerName) {
        return [
            trigger(triggerName, [
                state('*', style({
                    height: 0,
                    paddingTop: 0,
                    paddingBottom: 0,
                    borderBottom: 'none',
                    boxShadow: 'none',
                    overflow: 'hidden'
                })),
                state('true', style({
                    boxShadow: 'inset 0 4px 4px -2px rgb(208, 208, 208), inset 0 -3px 2px -1px rgb(208, 208, 208)',
                    overflow: 'inherit'
                })),
                transition('* => true', animate(CollapsibleAnimationsService.collapsibleBodyAnimationDuration + ' ' +
                    CollapsibleAnimationsService.easeInQuad)),
                transition('* => false', animate(CollapsibleAnimationsService.collapsibleBodyAnimationDuration + ' ' +
                    CollapsibleAnimationsService.easeOutQuad))
            ])
        ];
    };
    CollapsibleAnimationsService.collapsibleBodyAnimationDuration = '0.2s';
    CollapsibleAnimationsService.easeInQuad = 'cubic-bezier(0.55, 0.085, 0.68, 0.53)';
    CollapsibleAnimationsService.easeOutQuad = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)';
    CollapsibleAnimationsService.collapsibleTableRowAnimationDuration = '0.2s';
    CollapsibleAnimationsService.decorators = [
        { type: Injectable }
    ];
    return CollapsibleAnimationsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleBodyComponent = /** @class */ (function () {
    function CollapsibleBodyComponent(el, collapsibleService, eventService) {
        this.el = el;
        this.collapsibleService = collapsibleService;
        this.eventService = eventService;
        this.toggleState = new EventEmitter();
    }
    /**
     * @return {?}
     */
    CollapsibleBodyComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.eventService.toggleCollapsibleItem$.subscribe(function () {
            _this.toggleCollapsibleItem();
        });
    };
    /**
     * @return {?}
     */
    CollapsibleBodyComponent.prototype.hasContent = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.el.nativeElement.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if ((/** @type {?} */ (child)).tagName != null) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    /**
     * @return {?}
     */
    CollapsibleBodyComponent.prototype.toggleCollapsibleItem = /**
     * @return {?}
     */
    function () {
        // toggle body's state only if it has any childs
        if (this.hasContent()) {
            if (this.collapsibleService.getType() === 'accordion') {
                /** @type {?} */
                var tempExpanded = this.expanded;
                this.collapsibleService.collapseAll();
                this.expanded = tempExpanded;
            }
            this.expanded = !this.expanded;
            this.expandedState = this.expanded.toString();
            // emit 'toggleState' event
            this.toggleState.emit(this.expanded);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    CollapsibleBodyComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var e_2, _a;
        if (this.hasContent()) {
            try {
                for (var _b = __values(Object.keys(changes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (key === 'expanded' &&
                        changes["expanded"].currentValue != null) {
                        // this.expanded = changes.expanded.currentValue;
                        this.expandedState = this.expanded.toString();
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    // Makes sure we don't have a memory leak by destroying the
    // Subscription when our component is destroyed
    /**
     * @return {?}
     */
    CollapsibleBodyComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.eventService.unsubscribe();
    };
    CollapsibleBodyComponent.decorators = [
        { type: Component, args: [{
                    selector: 'collapsible-body',
                    template: "<ng-content></ng-content>",
                    animations: CollapsibleAnimationsService.collapsibleBodyAnimations('collapsibleBodyState'),
                    styles: ["\n        :host {\n            display: block;\n            border-bottom: 1px solid #ddd;\n            box-sizing: border-box;\n            padding: 2rem;\n        }\n\n        .side-nav :host {\n            padding: 0;\n        }\n\n        .side-nav :host,\n        .side-nav.fixed :host {\n            border: 0;\n            background-color: #fff;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    CollapsibleBodyComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: CollapsibleService },
        { type: CollapsibleEventService }
    ]; };
    CollapsibleBodyComponent.propDecorators = {
        expandedState: [{ type: HostBinding, args: ['@collapsibleBodyState',] }],
        expanded: [{ type: Input }],
        toggleState: [{ type: Output }]
    };
    return CollapsibleBodyComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleListItemComponent = /** @class */ (function () {
    function CollapsibleListItemComponent(collapsibleService) {
        this.collapsibleService = collapsibleService;
    }
    /**
     * @return {?}
     */
    CollapsibleListItemComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // store list bodies in 'CollapsibleService'
        this.contentListBodies.forEach(function (item) {
            _this.collapsibleService.addListBody(item);
        });
    };
    CollapsibleListItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'collapsible-list-item',
                    template: "\n        <ng-content select=\"collapsible-header\"></ng-content>\n        <ng-content select=\"collapsible-body\"></ng-content>\n    ",
                    providers: [CollapsibleEventService]
                }] }
    ];
    /** @nocollapse */
    CollapsibleListItemComponent.ctorParameters = function () { return [
        { type: CollapsibleService }
    ]; };
    CollapsibleListItemComponent.propDecorators = {
        contentListBodies: [{ type: ContentChildren, args: [CollapsibleBodyComponent,] }]
    };
    return CollapsibleListItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleListComponent = /** @class */ (function () {
    function CollapsibleListComponent(collapsibleService) {
        this.collapsibleService = collapsibleService;
        // component options
        //
        // describes the type of the collapsible list: 'accordion' or 'expandable'
        this.type = 'accordion';
    }
    /**
     * @return {?}
     */
    CollapsibleListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.collapsibleService.setType(this.type);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    CollapsibleListComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        for (var change in changes) {
            if (change === 'type') {
                this.type = changes["type"].currentValue;
                this.collapsibleService.setType(this.type);
            }
        }
    };
    CollapsibleListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'collapsible-list',
                    template: "<ng-content select=\"collapsible-list-item\"></ng-content>",
                    providers: [CollapsibleService],
                    styles: ["\n    :host {\n      display: block;\n      margin: 0.5rem 0 1rem 0;\n      border-top: 1px solid #ddd;\n      border-right: 1px solid #ddd;\n      border-left: 1px solid #ddd;\n      box-shadow:\n        0 2px 2px 0 rgba(0, 0, 0, 0.14),\n        0 1px 5px 0 rgba(0, 0, 0, 0.12),\n        0 3px 1px -2px rgba(0, 0, 0, 0.2);\n    }\n\n    .side-nav :host,\n    .side-nav.fixed :host {\n      border: none;\n      box-shadow: none;\n    }\n\n    :host(.popout) {\n      border: none;\n      box-shadow: none;\n    }\n\n    :host(.popout) > li {\n      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.16), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n      margin: 0 24px;\n      transition: margin 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n    }\n\n    .side-nav :host {\n      margin: 0;\n    }\n  "]
                }] }
    ];
    /** @nocollapse */
    CollapsibleListComponent.ctorParameters = function () { return [
        { type: CollapsibleService }
    ]; };
    CollapsibleListComponent.propDecorators = {
        type: [{ type: Input }],
        contentListItems: [{ type: ContentChildren, args: [CollapsibleListItemComponent,] }]
    };
    return CollapsibleListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleHeaderComponent = /** @class */ (function () {
    function CollapsibleHeaderComponent(eventService) {
        this.eventService = eventService;
    }
    /**
     * @return {?}
     */
    CollapsibleHeaderComponent.prototype.click = /**
     * @return {?}
     */
    function () {
        this.eventService.toggleCollapsibleItem();
    };
    CollapsibleHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'collapsible-header',
                    template: "<ng-content></ng-content>",
                    styles: ["\n        :host {\n            display: block;\n            cursor: pointer;\n            min-height: 3rem;\n            line-height: 3rem;\n            padding: 0 1rem;\n            background-color: #fff;\n            border-bottom: 1px solid #ddd;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    CollapsibleHeaderComponent.ctorParameters = function () { return [
        { type: CollapsibleEventService }
    ]; };
    CollapsibleHeaderComponent.propDecorators = {
        click: [{ type: HostListener, args: ['click',] }]
    };
    return CollapsibleHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleTableRowDetailComponent = /** @class */ (function () {
    function CollapsibleTableRowDetailComponent(collapsibleService) {
        this.collapsibleService = collapsibleService;
        this.subject = new Subject();
    }
    /**
     * @return {?}
     */
    CollapsibleTableRowDetailComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subject.asObservable().subscribe(function () {
            _this.viewListBodies.forEach(function (item) {
                item.toggleCollapsibleItem();
            });
        });
    };
    /**
     * @return {?}
     */
    CollapsibleTableRowDetailComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // store list bodies in 'CollapsibleService'
        this.viewListBodies.forEach(function (item) {
            _this.collapsibleService.addListBody(item);
        });
    };
    CollapsibleTableRowDetailComponent.decorators = [
        { type: Component, args: [{
                    selector: 'collapsible-table-row-detail',
                    template: "\n        <td colspan=\"100%\">\n            <collapsible-list-item>\n                <collapsible-body>\n                    <ng-content></ng-content>\n                </collapsible-body>\n            </collapsible-list-item>\n        </td>\n    ",
                    styles: ["\n        :host {\n            display: table-row;\n        }\n\n        :host collapsible-body,\n        :host td {\n            padding: 0;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    CollapsibleTableRowDetailComponent.ctorParameters = function () { return [
        { type: CollapsibleService }
    ]; };
    CollapsibleTableRowDetailComponent.propDecorators = {
        expanded: [{ type: Input }],
        viewListBodies: [{ type: ViewChildren, args: [CollapsibleBodyComponent,] }]
    };
    return CollapsibleTableRowDetailComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleTableRowComponent = /** @class */ (function () {
    function CollapsibleTableRowComponent(el, sanitizer, collapsibleService) {
        this.el = el;
        this.sanitizer = sanitizer;
        this.collapsibleService = collapsibleService;
        this.backgroundTransitionDuration = '0.3s';
        // transition-timing-function: easeInQuad
        this.backgroundTransitionTimingFunction = this.sanitizer
            .bypassSecurityTrustStyle(CollapsibleTableRowComponent.EASE_OUT_QUAD);
        this.isHeadRow = false;
        this.isBodyRow = false;
        this.isOddRow = false;
        this.isEvenRow = false;
        this.isParentStriped = false;
        this.isParentHighlight = false;
        this.parentAllowsSelect = false;
        this.parentAllowsSelectMultipleRows = false;
        this.parentAllowsDeselectingRows = false;
        this.dragSelection = false;
    }
    /**
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var elem = this.el.nativeElement;
        /** @type {?} */
        var tbody = elem.parentElement;
        if (tbody.tagName === 'TBODY') {
            /** @type {?} */
            var collapsibleTableRows = tbody.querySelectorAll('collapsible-table-row');
            for (var i = 0; i < collapsibleTableRows.length; i++) {
                /** @type {?} */
                var collapsibleTableRow = collapsibleTableRows[i];
                if (collapsibleTableRow === elem) {
                    this.index = i + 1;
                    break;
                }
            }
        }
        // retrieve parent CollapsibleTableComponent through the CollapsibleService
        this.parentCollapsibleTable = this.collapsibleService.getCollapsibleTable();
        if (this.parentCollapsibleTable != null) {
            // check if collapsible-table is marked to show striped table
            this.isParentStriped = this.parentCollapsibleTable.striped;
            // check if collapsible-table is marked to highlight current row
            this.isParentHighlight = this.parentCollapsibleTable.highlight;
            this.parentHighlightRowBackgroundColor = this.parentCollapsibleTable.highlightColor ||
                CollapsibleTableRowComponent.DEFAULT_HIGHLIGHT_ROW_COLOR;
            this.parentHighlightRowTextColor = this.parentCollapsibleTable.highlightTextColor ||
                CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
            // check if collapsible-table specifies the active row color
            this.activeRowBackgroundColor = this.parentCollapsibleTable.activeColor ||
                CollapsibleTableRowComponent.DEFAULT_ACTIVE_ROW_COLOR;
            this.activeRowTextColor = this.parentCollapsibleTable.activeTextColor ||
                CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
            // check if collapsible-table allows selecting rows
            this.parentAllowsSelect = this.parentCollapsibleTable.select;
            this.parentAllowsSelectMultipleRows = this.parentCollapsibleTable.selectMultipleRows;
            // check if collapsible-table specifies a color for the selected row
            this.selectedRowBackgroundColor = this.parentCollapsibleTable.selectColor ||
                CollapsibleTableRowComponent.DEFAULT_SELECTED_ROW_COLOR;
            this.selectedRowTextColor = this.parentCollapsibleTable.selectTextColor ||
                CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
            // check if collapsible-table allows to deselect rows
            this.parentAllowsDeselectingRows = this.parentCollapsibleTable.allowDeselectingRows != null ?
                this.parentCollapsibleTable.allowDeselectingRows : false;
        }
    };
    /**
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.updateRow();
    };
    /**
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.updateRow = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var elem = this.el.nativeElement;
        /** @type {?} */
        var th = elem.querySelector('th');
        if (th != null) {
            this.isHeadRow = true;
        }
        /** @type {?} */
        var td = elem.querySelector('td');
        if (td != null) {
            this.isBodyRow = true;
            // determine if the row is 'odd' or 'event'
            if (this.index % 2 === 0) {
                this.isEvenRow = true;
                this.parentStripedRowBackgroundColor = this.parentCollapsibleTable.stripedEvenColor ||
                    CollapsibleTableRowComponent.DEFAULT_STRIPED_EVEN_ROW_COLOR;
                this.parentStripedRowTextColor = this.parentCollapsibleTable.stripedEvenTextColor ||
                    CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
            }
            else {
                this.isOddRow = true;
                this.parentStripedRowBackgroundColor = this.parentCollapsibleTable.stripedOddColor ||
                    CollapsibleTableRowComponent.DEFAULT_STRIPED_ODD_ROW_COLOR;
                this.parentStripedRowTextColor = this.parentCollapsibleTable.stripedOddTextColor ||
                    CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
            }
            switch (true) {
                case this.parentAllowsSelect && this.selected:
                    this.rowBackgroundColor = this.selectedRowBackgroundColor;
                    this.rowTextColor = this.selectedRowTextColor;
                    break;
                case this.isParentStriped:
                    this.rowBackgroundColor = this.parentStripedRowBackgroundColor;
                    this.rowTextColor = this.parentStripedRowTextColor;
                    break;
            }
        }
    };
    /**
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.getHeight = /**
     * @return {?}
     */
    function () {
        return this.el.nativeElement.offsetHeight;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.isLeftMouseButton = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var button = event.button;
        /** @type {?} */
        var which = event['which'];
        /** @type {?} */
        var target = /** @type {?} */ ((event.target || event.srcElement || event.currentTarget));
        if (['TR', 'TD'].indexOf(target.tagName) > -1) {
            if ('button' in event) {
                return button === 0;
            }
            else {
                return (which || button) === 1;
            }
        }
        return false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.mousedown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // handle only if the Left mouse button pressed
        // and the row is a body row
        if (this.isLeftMouseButton(event) && this.isBodyRow) {
            if (this.parentCollapsibleTable.noTextSelect) {
                event.preventDefault();
            }
            if (this.isBodyRow) {
                if (this.parentAllowsSelect && !this.parentAllowsDeselectingRows) {
                    this.prevSelectedRows = this.parentCollapsibleTable.selectedRows;
                    this.parentCollapsibleTable.clearSelectedRows();
                    this.parentCollapsibleTable.deselectAllRows();
                }
                this.rowBackgroundColor = this.activeRowBackgroundColor;
                this.rowTextColor = this.activeRowTextColor;
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.mouseup = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // handle only if the Left mouse button pressed
        // and the row is a body row
        if (this.isLeftMouseButton(event) && this.isBodyRow) {
            // handle selection
            if (this.parentAllowsSelect) {
                if (!this.parentAllowsDeselectingRows) {
                    this.parentCollapsibleTable.selectRow(this.index);
                }
                else {
                    if (!this.dragSelection) {
                        this.parentCollapsibleTable.toggleRowSelection(this.index);
                    }
                }
            }
            // check row state
            this.parentCollapsibleTable.updateTable();
            /*switch (true) {
                            // parent allows selecting rows and the row is selected
                            case this.parentAllowsSelect && this.selected:
                                this.rowBackgroundColor = this.selectedRowBackgroundColor;
                                this.rowTextColor = this.selectedRowTextColor;
                                this.parentCollapsibleTable.updateTable();
                                break;
                            // highlighted
                            case this.isParentHighlight:
                                this.rowBackgroundColor = this.parentHighlightRowBackgroundColor;
                                this.rowTextColor = this.parentHighlightRowTextColor;
                                break;
                            // striped
                            case this.isParentStriped:
                                this.rowBackgroundColor = this.parentStripedRowBackgroundColor;
                                this.rowTextColor = this.parentStripedRowTextColor;
                                break;
                            default:
                                this.rowBackgroundColor = undefined;
                                this.rowTextColor = undefined;
                                break;
                        }*/
            // select multiple rows using the 'Shift' key
            if (this.parentAllowsSelect &&
                this.parentAllowsSelectMultipleRows &&
                event != null && event.shiftKey) {
                if (this.prevSelectedRows != null &&
                    this.prevSelectedRows.length > 0 &&
                    this.parentCollapsibleTable.selectedRows.length > 0) {
                    /** @type {?} */
                    var rangeSelectedRows = this.prevSelectedRows.concat(this.parentCollapsibleTable.selectedRows);
                    rangeSelectedRows.sort(function (a, b) { return a - b; });
                    /** @type {?} */
                    var firstRowIndex = Math.min.apply(null, rangeSelectedRows);
                    /** @type {?} */
                    var lastRowIndex = Math.max.apply(null, rangeSelectedRows);
                    this.parentCollapsibleTable.selectRows(firstRowIndex, lastRowIndex);
                }
            }
            // set dragSelection flag to false. Prevents selection drag behavior
            this.dragSelection = false;
            // focus the collapsible table
            this.parentCollapsibleTable.focus();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.mouseenter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // handle only if the row is a body row
        if (this.isBodyRow) {
            switch (true) {
                // the use is trying to select multiple rows by holding a mouse button
                case this.parentAllowsSelect && this.parentAllowsSelectMultipleRows && this.parentCollapsibleTable.mouseDownHold:
                    this.parentCollapsibleTable.selectRow(this.index);
                    this.dragSelection = true;
                    break;
                // parent allows selecting rows and the row is selected
                case this.parentAllowsSelect && this.selected:
                    break;
                // highlighted
                case this.isParentHighlight:
                    this.rowBackgroundColor = this.parentHighlightRowBackgroundColor;
                    this.rowTextColor = this.parentHighlightRowTextColor;
                    break;
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.mouseleave = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // handle only if the row is a body row
        if (this.isBodyRow) {
            // check row state
            switch (true) {
                // the use is trying to select multiple rows by holding a mouse button
                case this.parentAllowsSelect && this.parentAllowsSelectMultipleRows && this.parentCollapsibleTable.mouseDownHold:
                    this.parentCollapsibleTable.selectRow(this.index);
                    this.dragSelection = false;
                    break;
                // parent allows selecting rows and the row is selected
                case this.parentAllowsSelect && this.selected:
                    break;
                // stripped
                case this.isParentStriped:
                    this.rowBackgroundColor = this.parentStripedRowBackgroundColor;
                    this.rowTextColor = this.parentStripedRowTextColor;
                    break;
                default:
                    this.rowBackgroundColor = undefined;
                    this.rowTextColor = undefined;
                    break;
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CollapsibleTableRowComponent.prototype.click = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.detail != null) {
            /** @type {?} */
            var target = /** @type {?} */ ((event.target || event.srcElement || event.currentTarget));
            if (target != null && ['TR', 'TD'].indexOf(target.tagName) > -1) {
                this.detail.subject.next();
            }
        }
    };
    CollapsibleTableRowComponent.EASE_OUT_QUAD = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)';
    CollapsibleTableRowComponent.DEFAULT_STRIPED_ODD_ROW_COLOR = 'rgba(242,242,242,0.8)';
    CollapsibleTableRowComponent.DEFAULT_STRIPED_EVEN_ROW_COLOR = 'transparent';
    CollapsibleTableRowComponent.DEFAULT_HIGHLIGHT_ROW_COLOR = 'rgba(222,222,222, 0.8)';
    CollapsibleTableRowComponent.DEFAULT_ACTIVE_ROW_COLOR = 'rgba(212,212,212, 0.8)';
    CollapsibleTableRowComponent.DEFAULT_SELECTED_ROW_COLOR = 'rgba(212,212,212, 0.8)';
    CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR = 'black';
    CollapsibleTableRowComponent.decorators = [
        { type: Component, args: [{
                    selector: 'collapsible-table-row',
                    template: "<ng-content></ng-content>",
                    styles: ["\n        :host {\n            display: table-row;\n            transition-property: background-color, color;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    CollapsibleTableRowComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DomSanitizer },
        { type: CollapsibleService }
    ]; };
    CollapsibleTableRowComponent.propDecorators = {
        detail: [{ type: Input }],
        rowTextColor: [{ type: HostBinding, args: ['style.color',] }],
        rowBackgroundColor: [{ type: HostBinding, args: ['style.background-color',] }],
        backgroundTransitionDuration: [{ type: HostBinding, args: ['style.transition-duration',] }],
        backgroundTransitionTimingFunction: [{ type: HostBinding, args: ['style.transition-timing-function',] }],
        selected: [{ type: HostBinding, args: ['class.selected',] }],
        mousedown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
        mouseup: [{ type: HostListener, args: ['mouseup', ['$event'],] }],
        mouseenter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }],
        mouseleave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
        click: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return CollapsibleTableRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleTableComponent = /** @class */ (function () {
    function CollapsibleTableComponent(el, collapsibleService) {
        this.el = el;
        this.collapsibleService = collapsibleService;
        // allows navigation between table rows using arrow keys
        this.allowKeyboardNavigation = true;
        this.fixedTableHeight = 'auto';
        this.tabindex = 0;
        this.selectedRows = [];
        // specifies collapsible type. Can be either 'accordion' or 'expandable'
        this.type = 'accordion';
        this.mouseDownHold = false;
    }
    /**
     * @return {?}
     */
    CollapsibleTableComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    CollapsibleTableComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        // this.updateFixedTableHeight();
        /*
                LOG(`CollapsibleTableComponent::ngOnInit()\n` +
                    `this = {\n` +
                    `bordered = ${this.bordered}\n` +
                    `borderedHorizontally = ${this.borderedHorizontally}\n` +
                    `borderedVertically = ${this.borderedVertically}\n` +
                    `striped = ${this.striped}\n` +
                    `stripedOddColor = ${this.stripedOddColor}\n` +
                    `stripedEvenColor = ${this.stripedEvenColor}\n` +
                    `highlight = ${this.highlight}\n` +
                    `highlightColor = ${this.highlightColor}\n` +
                    `highlightTextColor = ${this.highlightTextColor}\n` +
                    `activeColor = ${this.activeColor}\n` +
                    `activeTextColor = ${this.activeTextColor}\n` +
                    `centered = ${this.centered}\n` +
                    `responsive = ${this.responsive}\n` +
                    `select = ${this.select}\n` +
                    `selectColor = ${this.selectColor}\n` +
                    `selectTextColor = ${this.selectTextColor}\n` +
                    `selectMultipleRows = ${this.selectMultipleRows}\n` +
                    `noTextSelect = ${this.noTextSelect}\n` +
                    `}`);
                    */
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    CollapsibleTableComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        for (var change in changes) {
            if (changes.hasOwnProperty(change)) {
                if (this.collapsibleTableRows != null) {
                    switch (change) {
                        case 'striped':
                        case 'stripedOddColor':
                        case 'stripedOddTextColor':
                        case 'stripedEvenColor':
                        case 'stripedEvenTextColor':
                            this.updateTable('striped');
                            break;
                        case 'highlight':
                        case 'highlightColor':
                        case 'highlightTextColor':
                            this.updateTable('highlight');
                            break;
                        case 'activeColor':
                        case 'activeTextColor':
                            this.updateTable('active');
                            break;
                        case 'select':
                        case 'selectColor':
                        case 'selectTextColor':
                        case 'selectMultipleRows':
                        case 'allowDeselectingRows':
                            this.updateTable('select');
                            break;
                    }
                }
                // update collapsible table type in CollapsibleService
                if (change === 'type') {
                    this.type = changes["type"].currentValue;
                    this.collapsibleService.setType(this.type);
                }
            }
        }
        this.collapsibleService.setCollapsibleTable(this);
    };
    /**
     * @return {?}
     */
    CollapsibleTableComponent.prototype.focus = /**
     * @return {?}
     */
    function () {
        this.el.nativeElement.focus();
    };
    /**
     * @param {?} index
     * @return {?}
     */
    CollapsibleTableComponent.prototype.addSelectedRow = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        switch (true) {
            case this.selectMultipleRows && this.selectedRows.indexOf(index) === -1:
                this.selectedRows.push(index);
                this.selectedRows.sort(function (a, b) { return a - b; });
                break;
            case !this.selectMultipleRows:
                this.selectedRows = [];
                this.deselectAllRows();
                this.selectedRows.push(index);
                this.selectedRows.sort(function (a, b) { return a - b; });
                break;
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    CollapsibleTableComponent.prototype.removeSelectedRow = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (this.selectedRows.indexOf(index) !== -1) {
            this.selectedRows.splice(this.selectedRows.indexOf(index), 1);
        }
    };
    /**
     * @return {?}
     */
    CollapsibleTableComponent.prototype.clearSelectedRows = /**
     * @return {?}
     */
    function () {
        this.selectedRows = [];
    };
    /**
     * @return {?}
     */
    CollapsibleTableComponent.prototype.deselectAllRows = /**
     * @return {?}
     */
    function () {
        this.collapsibleTableRows.forEach(function (row) {
            row.selected = false;
            row.updateRow();
        });
    };
    /**
     * @param {?} index
     * @return {?}
     */
    CollapsibleTableComponent.prototype.selectRow = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var _this = this;
        if (this.select) {
            switch (true) {
                case index === 0:
                    this.selectRow(1);
                    break;
                case index === this.collapsibleTableRows.length:
                    this.selectRow(this.collapsibleTableRows.length - 1);
                    break;
                case 0 < index && index <= this.collapsibleTableRows.length - 1:
                    this.addSelectedRow(index);
                    this.collapsibleTableRows.forEach(function (row, i) {
                        if (index !== i) {
                            if (!_this.selectMultipleRows) {
                                row.selected = false;
                            }
                        }
                        else {
                            row.selected = true;
                        }
                        row.updateRow();
                    });
                    break;
            }
        }
    };
    /**
     * @param {?} firstRowIndex
     * @param {?} lastRowIndex
     * @return {?}
     */
    CollapsibleTableComponent.prototype.selectRows = /**
     * @param {?} firstRowIndex
     * @param {?} lastRowIndex
     * @return {?}
     */
    function (firstRowIndex, lastRowIndex) {
        var _this = this;
        if (this.selectMultipleRows &&
            0 < firstRowIndex && firstRowIndex < lastRowIndex &&
            lastRowIndex <= this.collapsibleTableRows.length - 1) {
            this.clearSelectedRows();
            this.collapsibleTableRows.forEach(function (row, i) {
                if (firstRowIndex <= i && i <= lastRowIndex) {
                    _this.addSelectedRow(i);
                    row.selected = true;
                }
                else {
                    row.selected = false;
                }
                row.updateRow();
            });
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    CollapsibleTableComponent.prototype.toggleRowSelection = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var _this = this;
        if (this.select &&
            0 < index && index <= this.collapsibleTableRows.length - 1) {
            this.collapsibleTableRows.forEach(function (row, i) {
                if (index === i) {
                    if (row.selected) {
                        _this.removeSelectedRow(index);
                    }
                    else {
                        _this.addSelectedRow(index);
                    }
                    row.selected = !row.selected;
                    row.updateRow();
                }
            });
        }
    };
    /*updateFixedTableHeight() {
        this.fixedTableHeight = this.el.nativeElement.offsetHeight + 'px';
        let elem: Element = this.el.nativeElement;
        let rowHeights = 0;
        if (this.collapsibleTableRowComponent != null) {
            this.collapsibleTableRowComponent.forEach(row => {
            });
        }
    }*/
    /**
     * @param {?} row
     * @return {?}
     */
    CollapsibleTableComponent.prototype.updateStriped = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        if (this.striped && row.isBodyRow) {
            row.isParentStriped = true;
            if (row.isOddRow) {
                row.parentStripedRowBackgroundColor = this.stripedOddColor || CollapsibleTableRowComponent.DEFAULT_STRIPED_ODD_ROW_COLOR;
                row.parentStripedRowTextColor = this.stripedOddTextColor || CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
                row.rowBackgroundColor = row.parentStripedRowBackgroundColor;
                row.rowTextColor = row.parentStripedRowTextColor;
            }
            else {
                row.parentStripedRowBackgroundColor = this.stripedEvenColor || CollapsibleTableRowComponent.DEFAULT_STRIPED_EVEN_ROW_COLOR;
                row.parentStripedRowTextColor = this.stripedEvenTextColor || CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
                row.rowBackgroundColor = row.parentStripedRowBackgroundColor;
                row.rowTextColor = row.parentStripedRowTextColor;
            }
        }
        else {
            row.isParentStriped = false;
            row.rowBackgroundColor = undefined;
            row.rowTextColor = undefined;
        }
    };
    /**
     * @param {?} row
     * @return {?}
     */
    CollapsibleTableComponent.prototype.updateHighlight = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        row.isParentHighlight = this.highlight;
        row.parentHighlightRowBackgroundColor = this.highlightColor || CollapsibleTableRowComponent.DEFAULT_HIGHLIGHT_ROW_COLOR;
        row.parentHighlightRowTextColor = this.highlightTextColor || CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
    };
    /**
     * @param {?} row
     * @return {?}
     */
    CollapsibleTableComponent.prototype.updateActive = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        row.activeRowBackgroundColor = this.activeColor || CollapsibleTableRowComponent.DEFAULT_ACTIVE_ROW_COLOR;
        row.activeRowTextColor = this.activeTextColor || CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
    };
    /**
     * @param {?} row
     * @return {?}
     */
    CollapsibleTableComponent.prototype.updateSelect = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        row.parentAllowsSelect = this.select;
        row.parentAllowsSelectMultipleRows = this.selectMultipleRows;
        row.parentAllowsDeselectingRows = this.allowDeselectingRows;
        if (row.selected) {
            row.selectedRowBackgroundColor = this.selectColor || CollapsibleTableRowComponent.DEFAULT_SELECTED_ROW_COLOR;
            row.selectedRowTextColor = this.selectTextColor || CollapsibleTableRowComponent.DEFAULT_ROW_TEXT_COLOR;
            row.rowBackgroundColor = row.selectedRowBackgroundColor;
            row.rowTextColor = row.selectedRowTextColor;
        }
    };
    /**
     * @param {?=} change
     * @return {?}
     */
    CollapsibleTableComponent.prototype.updateTable = /**
     * @param {?=} change
     * @return {?}
     */
    function (change) {
        var _this = this;
        if (this.collapsibleTableRows != null) {
            if (change != null) {
                switch (change) {
                    case 'striped':
                        // propagate changes to each of the CollapsibleTableRowComponent children
                        this.collapsibleTableRows.forEach(function (row) { _this.updateStriped(row); });
                        break;
                    case 'highlight':
                        this.collapsibleTableRows.forEach(function (row) { _this.updateHighlight(row); });
                        break;
                    case 'active':
                        this.collapsibleTableRows.forEach(function (row) { _this.updateActive(row); });
                        break;
                    case 'select':
                        this.collapsibleTableRows.forEach(function (row) { _this.updateSelect(row); });
                        break;
                }
            }
            else {
                // propagate changes to each of the CollapsibleTableRowComponent children
                this.collapsibleTableRows.forEach(function (row) {
                    _this.updateStriped(row);
                    _this.updateHighlight(row);
                    _this.updateSelect(row);
                    _this.updateActive(row);
                });
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CollapsibleTableComponent.prototype.keydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // select a row only if 'select' property is set to 'true'
        if (this.select && this.allowKeyboardNavigation) {
            /** @enum {number} */
            var Key = {
                arrowUp: 38,
                arrowDown: 40,
                home: 36,
                end: 35,
            };
            Key[Key.arrowUp] = 'arrowUp';
            Key[Key.arrowDown] = 'arrowDown';
            Key[Key.home] = 'home';
            Key[Key.end] = 'end';
            /** @type {?} */
            var index = 1;
            /** @type {?} */
            var whichKey = event['which'];
            if (Key[whichKey] != null) {
                event.preventDefault();
                event.stopPropagation();
                switch (whichKey) {
                    case Key.arrowUp:
                        // select previous row
                        if (this.selectedRows.length > 0) {
                            index = this.selectedRows[this.selectedRows.length - 1];
                            index--;
                        }
                        break;
                    case Key.arrowDown:
                        // select next row
                        if (this.selectedRows.length > 0) {
                            index = this.selectedRows[this.selectedRows.length - 1];
                            index++;
                        }
                        break;
                    case Key.home:
                        index = 1;
                        break;
                    case Key.end:
                        index = this.collapsibleTableRows.length - 1;
                        break;
                }
                this.clearSelectedRows();
                this.deselectAllRows();
                this.selectRow(index);
                this.updateTable();
            }
        }
    };
    /**
     * @return {?}
     */
    CollapsibleTableComponent.prototype.mousedown = /**
     * @return {?}
     */
    function () {
        this.mouseDownHold = true;
    };
    /**
     * @return {?}
     */
    CollapsibleTableComponent.prototype.mouseup = /**
     * @return {?}
     */
    function () {
        this.mouseDownHold = false;
    };
    CollapsibleTableComponent.decorators = [
        { type: Component, args: [{
                    selector: 'collapsible-table',
                    template: "<ng-content></ng-content>",
                    providers: [
                        CollapsibleService
                    ],
                    styles: ["\n        :host {\n            display: table;\n            position: relative;\n            width: 100%;\n            border-collapse: collapse;\n        }\n\n        :host thead {\n            border-bottom: 1px solid #d0d0d0;\n        }\n\n        :host /deep/ tbody /deep/ collapsible-table-row {\n            cursor: pointer;\n        }\n\n        :host /deep/ collapsible-table-row th,\n        :host /deep/ collapsible-table-row td {\n            border-radius: 0;\n        }\n\n        :host[bordered='true'] {\n            border-top: 1px solid #d0d0d0;\n            border-right: 1px solid #d0d0d0;\n            border-left: 1px solid #d0d0d0;\n        }\n\n        :host[bordered='true'] /deep/ collapsible-table-row,\n        :host[borderedHorizontally='true'] /deep/ collapsible-table-row {\n            border-bottom: 1px solid #d0d0d0;\n        }\n\n        :host[bordered='true'] /deep/ collapsible-table-row th,\n        :host[bordered='true'] /deep/ collapsible-table-row td,\n        :host[borderedVertically='true'] /deep/ collapsible-table-row th:not(:last-child),\n        :host[borderedVertically='true'] /deep/ collapsible-table-row td:not(:last-child) {\n            border-right: 1px solid #d0d0d0;\n        }\n\n        :host(.centered) /deep/ * {\n            text-align: center;\n        }\n\n        :host(.noTextSelect) /deep/ collapsible-table-row th,\n        :host(.noTextSelect) /deep/ collapsible-table-row td {\n            user-select: none;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    CollapsibleTableComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: CollapsibleService }
    ]; };
    CollapsibleTableComponent.propDecorators = {
        bordered: [{ type: Input }, { type: HostBinding, args: ['attr.bordered',] }],
        borderedHorizontally: [{ type: Input }, { type: HostBinding, args: ['attr.borderedHorizontally',] }],
        borderedVertically: [{ type: Input }, { type: HostBinding, args: ['attr.borderedVertically',] }],
        striped: [{ type: Input }, { type: HostBinding, args: ['attr.striped',] }],
        stripedOddColor: [{ type: Input }, { type: HostBinding, args: ['attr.stripedOddColor',] }],
        stripedOddTextColor: [{ type: Input }, { type: HostBinding, args: ['attr.stripedOddTextColor',] }],
        stripedEvenColor: [{ type: Input }, { type: HostBinding, args: ['attr.stripedEvenColor',] }],
        stripedEvenTextColor: [{ type: Input }, { type: HostBinding, args: ['attr.stripedEvenTextColor',] }],
        highlight: [{ type: Input }, { type: HostBinding, args: ['attr.highlight',] }],
        highlightColor: [{ type: Input }, { type: HostBinding, args: ['attr.highlightColor',] }],
        highlightTextColor: [{ type: Input }, { type: HostBinding, args: ['attr.highlightTextColor',] }],
        activeColor: [{ type: Input }, { type: HostBinding, args: ['attr.activeColor',] }],
        activeTextColor: [{ type: Input }, { type: HostBinding, args: ['attr.activeTextColor',] }],
        centered: [{ type: Input }, { type: HostBinding, args: ['class.centered',] }, { type: HostBinding, args: ['attr.centered',] }],
        responsive: [{ type: Input }, { type: HostBinding, args: ['attr.responsive',] }],
        select: [{ type: Input }, { type: HostBinding, args: ['attr.select',] }],
        selectMultipleRows: [{ type: Input }, { type: HostBinding, args: ['attr.selectMultipleRows',] }],
        selectColor: [{ type: Input }, { type: HostBinding, args: ['attr.selectColor',] }],
        selectTextColor: [{ type: Input }, { type: HostBinding, args: ['attr.selectTextColor',] }],
        allowDeselectingRows: [{ type: Input }, { type: HostBinding, args: ['attr.allowDeselectingRows',] }],
        allowKeyboardNavigation: [{ type: Input }, { type: HostBinding, args: ['attr.allowKeyboardNavigation',] }],
        noTextSelect: [{ type: Input }, { type: HostBinding, args: ['class.noTextSelect',] }, { type: HostBinding, args: ['attr.noTextSelect',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        type: [{ type: Input }, { type: HostBinding, args: ['attr.type',] }],
        collapsibleTableRows: [{ type: ContentChildren, args: [CollapsibleTableRowComponent,] }],
        keydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
        mousedown: [{ type: HostListener, args: ['mousedown',] }],
        mouseup: [{ type: HostListener, args: ['mouseup',] }]
    };
    return CollapsibleTableComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CollapsibleModule = /** @class */ (function () {
    function CollapsibleModule() {
    }
    /**
     * @return {?}
     */
    CollapsibleModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: CollapsibleModule,
            providers: [CollapsibleModule]
        };
    };
    CollapsibleModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        CollapsibleListComponent,
                        CollapsibleListItemComponent,
                        CollapsibleHeaderComponent,
                        CollapsibleBodyComponent,
                        CollapsibleTableComponent,
                        CollapsibleTableRowComponent,
                        CollapsibleTableRowDetailComponent
                    ],
                    exports: [
                        CollapsibleListComponent,
                        CollapsibleListItemComponent,
                        CollapsibleHeaderComponent,
                        CollapsibleBodyComponent,
                        CollapsibleTableComponent,
                        CollapsibleTableRowComponent,
                        CollapsibleTableRowDetailComponent
                    ],
                    providers: [
                        CollapsibleService,
                        CollapsibleEventService,
                        CollapsibleAnimationsService
                    ]
                },] }
    ];
    return CollapsibleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { CollapsibleModule, CollapsibleService, CollapsibleEvent, CollapsibleEventService, CollapsibleAnimationsService, CollapsibleHeaderComponent, CollapsibleBodyComponent, CollapsibleListComponent, CollapsibleListItemComponent, CollapsibleTableComponent, CollapsibleTableRowComponent, CollapsibleTableRowDetailComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjItY29sbGFwc2libGUuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXIyLWNvbGxhcHNpYmxlL2xpYi9zZXJ2aWNlcy9jb2xsYXBzaWJsZS5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyMi1jb2xsYXBzaWJsZS9saWIvc2VydmljZXMvY29sbGFwc2libGUtZXZlbnQuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhcjItY29sbGFwc2libGUvbGliL3NlcnZpY2VzL2NvbGxhcHNpYmxlLWFuaW1hdGlvbnMuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhcjItY29sbGFwc2libGUvbGliL2NvbGxhcHNpYmxlLWJvZHkvY29sbGFwc2libGUtYm9keS5jb21wb25lbnQudHMiLCJuZzovL2FuZ3VsYXIyLWNvbGxhcHNpYmxlL2xpYi9jb2xsYXBzaWJsZS1saXN0LWl0ZW0vY29sbGFwc2libGUtbGlzdC1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vYW5ndWxhcjItY29sbGFwc2libGUvbGliL2NvbGxhcHNpYmxlLWxpc3QvY29sbGFwc2libGUtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL2FuZ3VsYXIyLWNvbGxhcHNpYmxlL2xpYi9jb2xsYXBzaWJsZS1oZWFkZXIvY29sbGFwc2libGUtaGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vYW5ndWxhcjItY29sbGFwc2libGUvbGliL2NvbGxhcHNpYmxlLXRhYmxlLXJvdy1kZXRhaWwvY29sbGFwc2libGUtdGFibGUtcm93LWRldGFpbC5jb21wb25lbnQudHMiLCJuZzovL2FuZ3VsYXIyLWNvbGxhcHNpYmxlL2xpYi9jb2xsYXBzaWJsZS10YWJsZS1yb3cvY29sbGFwc2libGUtdGFibGUtcm93LmNvbXBvbmVudC50cyIsIm5nOi8vYW5ndWxhcjItY29sbGFwc2libGUvbGliL2NvbGxhcHNpYmxlLXRhYmxlL2NvbGxhcHNpYmxlLXRhYmxlLmNvbXBvbmVudC50cyIsIm5nOi8vYW5ndWxhcjItY29sbGFwc2libGUvbGliL2NvbGxhcHNpYmxlLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENvbGxhcHNpYmxlVGFibGVDb21wb25lbnQgfSBmcm9tICcuLi9jb2xsYXBzaWJsZS10YWJsZS9jb2xsYXBzaWJsZS10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sbGFwc2libGVIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuLi9jb2xsYXBzaWJsZS1oZWFkZXIvY29sbGFwc2libGUtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2xsYXBzaWJsZUJvZHlDb21wb25lbnQgfSBmcm9tICcuLi9jb2xsYXBzaWJsZS1ib2R5L2NvbGxhcHNpYmxlLWJvZHkuY29tcG9uZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbGxhcHNpYmxlU2VydmljZSB7XG4gICAgdHlwZTogJ2FjY29yZGlvbicgfCAnZXhwYW5kYWJsZSc7XG5cbiAgICBjb2xsYXBzaWJsZVRhYmxlOiBDb2xsYXBzaWJsZVRhYmxlQ29tcG9uZW50O1xuICAgIGhlYWRlcnM6IEFycmF5PENvbGxhcHNpYmxlSGVhZGVyQ29tcG9uZW50PiA9IG5ldyBBcnJheTxDb2xsYXBzaWJsZUhlYWRlckNvbXBvbmVudD4oKTtcbiAgICBib2RpZXM6IEFycmF5PENvbGxhcHNpYmxlQm9keUNvbXBvbmVudD4gPSBuZXcgQXJyYXk8Q29sbGFwc2libGVCb2R5Q29tcG9uZW50PigpO1xuXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9XG5cbiAgICBzZXRUeXBlKHR5cGU6ICdhY2NvcmRpb24nIHwgJ2V4cGFuZGFibGUnKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuXG4gICAgZ2V0Q29sbGFwc2libGVUYWJsZSgpOiBDb2xsYXBzaWJsZVRhYmxlQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2libGVUYWJsZTtcbiAgICB9XG5cbiAgICBzZXRDb2xsYXBzaWJsZVRhYmxlKHRhYmxlOiBDb2xsYXBzaWJsZVRhYmxlQ29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2libGVUYWJsZSA9IHRhYmxlO1xuICAgIH1cblxuICAgIGFkZExpc3RIZWFkZXIoaGVhZGVyOiBDb2xsYXBzaWJsZUhlYWRlckNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYWRlcnMucHVzaChoZWFkZXIpO1xuICAgIH1cblxuICAgIGFkZExpc3RCb2R5KGJvZHk6IENvbGxhcHNpYmxlQm9keUNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xuICAgIH1cblxuICAgIGNvbGxhcHNlQWxsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJvZGllcy5mb3JFYWNoKChjb2xsYXBzaWJsZUJvZHlDb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgIC8vIHNldCAnZXhwYW5kZWQnIHByb3BlcnRpZXMgb2YgYWxsIHRoZSBDb2xsYXBzaWJsZUJvZHlDb21wb25lbnRzIHRvICdmYWxzZSdcbiAgICAgICAgICAgIGNvbGxhcHNpYmxlQm9keUNvbXBvbmVudC5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29sbGFwc2libGVCb2R5Q29tcG9uZW50LmV4cGFuZGVkU3RhdGUgPSBjb2xsYXBzaWJsZUJvZHlDb21wb25lbnQuZXhwYW5kZWQudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgLy8gZW1pdCAndG9nZ2xlU3RhdGUnIGV2ZW50IGZvciBhbGwgdGhlIENvbGxhcHNpYmxlQm9keUNvbXBvbmVudHNcbiAgICAgICAgICAgIGNvbGxhcHNpYmxlQm9keUNvbXBvbmVudC50b2dnbGVTdGF0ZS5lbWl0KGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCBjbGFzcyBDb2xsYXBzaWJsZUV2ZW50IHtcbiAgICB0eXBlOiBzdHJpbmc7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb2xsYXBzaWJsZUV2ZW50U2VydmljZSB7XG4gICAgdHlwZTogJ2FjY29yZGlvbicgfCAnZXhwYW5kYWJsZSc7XG4gICAgLy8gT2JzZXJ2YWJsZSBzdHJpbmcgc291cmNlc1xuICAgIHByaXZhdGUgdG9nZ2xlQ29sbGFwc2libGVJdGVtU291cmNlID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgLy8gT2JzZXJ2YWJsZSBzdHJpbmcgc3RyZWFtc1xuICAgIHRvZ2dsZUNvbGxhcHNpYmxlSXRlbSQgPSB0aGlzLnRvZ2dsZUNvbGxhcHNpYmxlSXRlbVNvdXJjZS5hc09ic2VydmFibGUoKTtcblxuICAgIC8vIFRvZ2dsZSBjb2xsYXBzaWJsZSBpdGVtXG4gICAgdG9nZ2xlQ29sbGFwc2libGVJdGVtKGV2ZW50PzogQ29sbGFwc2libGVFdmVudCkge1xuICAgICAgICB0aGlzLnRvZ2dsZUNvbGxhcHNpYmxlSXRlbVNvdXJjZS5uZXh0KGV2ZW50KTtcbiAgICB9XG5cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy50b2dnbGVDb2xsYXBzaWJsZUl0ZW1Tb3VyY2UudW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSwgdHJpZ2dlciwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCBhbmltYXRlIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb2xsYXBzaWJsZUFuaW1hdGlvbnNTZXJ2aWNlIHtcblxuICAgIHN0YXRpYyBjb2xsYXBzaWJsZUJvZHlBbmltYXRpb25EdXJhdGlvbiA9ICcwLjJzJztcbiAgICBzdGF0aWMgZWFzZUluUXVhZCA9ICdjdWJpYy1iZXppZXIoMC41NSwgMC4wODUsIDAuNjgsIDAuNTMpJztcbiAgICBzdGF0aWMgZWFzZU91dFF1YWQgPSAnY3ViaWMtYmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpJztcblxuICAgIHN0YXRpYyBjb2xsYXBzaWJsZVRhYmxlUm93QW5pbWF0aW9uRHVyYXRpb24gPSAnMC4ycyc7XG5cbiAgICBzdGF0aWMgY29sbGFwc2libGVCb2R5QW5pbWF0aW9ucyh0cmlnZ2VyTmFtZTogc3RyaW5nKTogQW5pbWF0aW9uVHJpZ2dlck1ldGFkYXRhW10ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHJpZ2dlcih0cmlnZ2VyTmFtZSwgW1xuICAgICAgICAgICAgICAgIHN0YXRlKCcqJywgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDAsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIHN0YXRlKCd0cnVlJywgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6ICdpbnNldCAwIDRweCA0cHggLTJweCByZ2IoMjA4LCAyMDgsIDIwOCksIGluc2V0IDAgLTNweCAycHggLTFweCByZ2IoMjA4LCAyMDgsIDIwOCknLFxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2luaGVyaXQnXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gdHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoQ29sbGFwc2libGVBbmltYXRpb25zU2VydmljZS5jb2xsYXBzaWJsZUJvZHlBbmltYXRpb25EdXJhdGlvbiArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBDb2xsYXBzaWJsZUFuaW1hdGlvbnNTZXJ2aWNlLmVhc2VJblF1YWQpKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IGZhbHNlJyxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZShDb2xsYXBzaWJsZUFuaW1hdGlvbnNTZXJ2aWNlLmNvbGxhcHNpYmxlQm9keUFuaW1hdGlvbkR1cmF0aW9uICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbGxhcHNpYmxlQW5pbWF0aW9uc1NlcnZpY2UuZWFzZU91dFF1YWQpKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvKlxuICAgIHN0YXRpYyBjb2xsYXBzaWJsZVRhYmxlUm93QW5pbWF0aW9ucyh0cmlnZ2VyTmFtZTogc3RyaW5nKTogQW5pbWF0aW9uVHJpZ2dlck1ldGFkYXRhW10ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHJpZ2dlcih0cmlnZ2VyTmFtZSwgW1xuICAgICAgICAgICAgICAgIHN0YXRlKCdhY3RpdmUnLCBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDAsIDAsIDAsIDAuMTUpJ1xuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBzdGF0ZSgnaW5hY3RpdmUnLCBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiBhY3RpdmUnLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKENvbGxhcHNpYmxlQW5pbWF0aW9uc1NlcnZpY2UuY29sbGFwc2libGVUYWJsZVJvd0FuaW1hdGlvbkR1cmF0aW9uICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbGxhcHNpYmxlQW5pbWF0aW9uc1NlcnZpY2UuZWFzZU91dFF1YWQpKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IGluYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZShDb2xsYXBzaWJsZUFuaW1hdGlvbnNTZXJ2aWNlLmNvbGxhcHNpYmxlVGFibGVSb3dBbmltYXRpb25EdXJhdGlvbiArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBDb2xsYXBzaWJsZUFuaW1hdGlvbnNTZXJ2aWNlLmVhc2VPdXRRdWFkKSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF07XG4gICAgfVxuICAgICovXG59XG4iLCJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLFxuICAgIElucHV0LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZyxcbiAgICBPdXRwdXQsIEV2ZW50RW1pdHRlclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29sbGFwc2libGVTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvY29sbGFwc2libGUuc2VydmljZSc7XG5pbXBvcnQgeyBDb2xsYXBzaWJsZUV2ZW50U2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2NvbGxhcHNpYmxlLWV2ZW50LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29sbGFwc2libGVBbmltYXRpb25zU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2NvbGxhcHNpYmxlLWFuaW1hdGlvbnMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnY29sbGFwc2libGUtYm9keScsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgICBzdHlsZXM6IFtgXG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgcGFkZGluZzogMnJlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5zaWRlLW5hdiA6aG9zdCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLnNpZGUtbmF2IDpob3N0LFxuICAgICAgICAuc2lkZS1uYXYuZml4ZWQgOmhvc3Qge1xuICAgICAgICAgICAgYm9yZGVyOiAwO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgICAgICAgfVxuICAgIGBdLFxuICAgIGFuaW1hdGlvbnM6IENvbGxhcHNpYmxlQW5pbWF0aW9uc1NlcnZpY2UuY29sbGFwc2libGVCb2R5QW5pbWF0aW9ucygnY29sbGFwc2libGVCb2R5U3RhdGUnKVxufSlcbmV4cG9ydCBjbGFzcyBDb2xsYXBzaWJsZUJvZHlDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgICBASG9zdEJpbmRpbmcoJ0Bjb2xsYXBzaWJsZUJvZHlTdGF0ZScpXG4gICAgZXhwYW5kZWRTdGF0ZTogc3RyaW5nO1xuXG4gICAgQElucHV0KCkgZXhwYW5kZWQ6IGJvb2xlYW47XG5cbiAgICBAT3V0cHV0KCkgdG9nZ2xlU3RhdGUgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBjb2xsYXBzaWJsZVNlcnZpY2U6IENvbGxhcHNpYmxlU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBldmVudFNlcnZpY2U6IENvbGxhcHNpYmxlRXZlbnRTZXJ2aWNlKSB7IH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS50b2dnbGVDb2xsYXBzaWJsZUl0ZW0kLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUNvbGxhcHNpYmxlSXRlbSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYXNDb250ZW50KCk6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoKDxFbGVtZW50PmNoaWxkKS50YWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdG9nZ2xlQ29sbGFwc2libGVJdGVtKCkge1xuICAgICAgICAvLyB0b2dnbGUgYm9keSdzIHN0YXRlIG9ubHkgaWYgaXQgaGFzIGFueSBjaGlsZHNcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29udGVudCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzaWJsZVNlcnZpY2UuZ2V0VHlwZSgpID09PSAnYWNjb3JkaW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBFeHBhbmRlZCA9IHRoaXMuZXhwYW5kZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzaWJsZVNlcnZpY2UuY29sbGFwc2VBbGwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gdGVtcEV4cGFuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZFN0YXRlID0gdGhpcy5leHBhbmRlZC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAvLyBlbWl0ICd0b2dnbGVTdGF0ZScgZXZlbnRcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlU3RhdGUuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29udGVudCgpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjaGFuZ2VzKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdleHBhbmRlZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5leHBhbmRlZC5jdXJyZW50VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmV4cGFuZGVkID0gY2hhbmdlcy5leHBhbmRlZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRTdGF0ZSA9IHRoaXMuZXhwYW5kZWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIGRvbid0IGhhdmUgYSBtZW1vcnkgbGVhayBieSBkZXN0cm95aW5nIHRoZVxuICAgIC8vIFN1YnNjcmlwdGlvbiB3aGVuIG91ciBjb21wb25lbnQgaXMgZGVzdHJveWVkXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbnRlbnRDaGlsZHJlblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29sbGFwc2libGVCb2R5Q29tcG9uZW50IH0gZnJvbSAnLi4vY29sbGFwc2libGUtYm9keS9jb2xsYXBzaWJsZS1ib2R5LmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IENvbGxhcHNpYmxlU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2NvbGxhcHNpYmxlLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29sbGFwc2libGVFdmVudFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jb2xsYXBzaWJsZS1ldmVudC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdjb2xsYXBzaWJsZS1saXN0LWl0ZW0nLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNvbGxhcHNpYmxlLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY29sbGFwc2libGUtYm9keVwiPjwvbmctY29udGVudD5cbiAgICBgLFxuICAgIHByb3ZpZGVyczogW0NvbGxhcHNpYmxlRXZlbnRTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBDb2xsYXBzaWJsZUxpc3RJdGVtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKENvbGxhcHNpYmxlQm9keUNvbXBvbmVudCkgY29udGVudExpc3RCb2RpZXM6IEFycmF5PENvbGxhcHNpYmxlQm9keUNvbXBvbmVudD47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbGxhcHNpYmxlU2VydmljZTogQ29sbGFwc2libGVTZXJ2aWNlKSB7IH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgLy8gc3RvcmUgbGlzdCBib2RpZXMgaW4gJ0NvbGxhcHNpYmxlU2VydmljZSdcbiAgICAgICAgdGhpcy5jb250ZW50TGlzdEJvZGllcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNpYmxlU2VydmljZS5hZGRMaXN0Qm9keShpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIE9uSW5pdCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLFxuICBJbnB1dCxcbiAgQ29udGVudENoaWxkcmVuXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb2xsYXBzaWJsZUxpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sbGFwc2libGUtbGlzdC1pdGVtL2NvbGxhcHNpYmxlLWxpc3QtaXRlbS5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBDb2xsYXBzaWJsZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jb2xsYXBzaWJsZS5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sbGFwc2libGUtbGlzdCcsXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY29sbGFwc2libGUtbGlzdC1pdGVtXCI+PC9uZy1jb250ZW50PmAsXG4gIHN0eWxlczogW2BcbiAgICA6aG9zdCB7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIG1hcmdpbjogMC41cmVtIDAgMXJlbSAwO1xuICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XG4gICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZGRkO1xuICAgICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZGRkO1xuICAgICAgYm94LXNoYWRvdzpcbiAgICAgICAgMCAycHggMnB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgMCAxcHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgMCAzcHggMXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAgIH1cblxuICAgIC5zaWRlLW5hdiA6aG9zdCxcbiAgICAuc2lkZS1uYXYuZml4ZWQgOmhvc3Qge1xuICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICB9XG5cbiAgICA6aG9zdCgucG9wb3V0KSB7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBib3gtc2hhZG93OiBub25lO1xuICAgIH1cblxuICAgIDpob3N0KC5wb3BvdXQpID4gbGkge1xuICAgICAgYm94LXNoYWRvdzogMCAycHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjE2KSwgMCAycHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xMik7XG4gICAgICBtYXJnaW46IDAgMjRweDtcbiAgICAgIHRyYW5zaXRpb246IG1hcmdpbiAwLjM1cyBjdWJpYy1iZXppZXIoMC4yNSwgMC40NiwgMC40NSwgMC45NCk7XG4gICAgfVxuXG4gICAgLnNpZGUtbmF2IDpob3N0IHtcbiAgICAgIG1hcmdpbjogMDtcbiAgICB9XG4gIGBdLFxuICBwcm92aWRlcnM6IFtDb2xsYXBzaWJsZVNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIENvbGxhcHNpYmxlTGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgLy8gY29tcG9uZW50IG9wdGlvbnNcbiAgLy9cbiAgLy8gZGVzY3JpYmVzIHRoZSB0eXBlIG9mIHRoZSBjb2xsYXBzaWJsZSBsaXN0OiAnYWNjb3JkaW9uJyBvciAnZXhwYW5kYWJsZSdcbiAgQElucHV0KCkgdHlwZTogJ2FjY29yZGlvbicgfCAnZXhwYW5kYWJsZScgPSAnYWNjb3JkaW9uJztcblxuICBAQ29udGVudENoaWxkcmVuKENvbGxhcHNpYmxlTGlzdEl0ZW1Db21wb25lbnQpIGNvbnRlbnRMaXN0SXRlbXM6IEFycmF5PENvbGxhcHNpYmxlTGlzdEl0ZW1Db21wb25lbnQ+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29sbGFwc2libGVTZXJ2aWNlOiBDb2xsYXBzaWJsZVNlcnZpY2UpIHsgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuY29sbGFwc2libGVTZXJ2aWNlLnNldFR5cGUodGhpcy50eXBlKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBpbiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoY2hhbmdlID09PSAndHlwZScpIHtcbiAgICAgICAgdGhpcy50eXBlID0gY2hhbmdlcy50eXBlLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgdGhpcy5jb2xsYXBzaWJsZVNlcnZpY2Uuc2V0VHlwZSh0aGlzLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29sbGFwc2libGVFdmVudFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jb2xsYXBzaWJsZS1ldmVudC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdjb2xsYXBzaWJsZS1oZWFkZXInLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmAsXG4gICAgc3R5bGVzOiBbYFxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgIG1pbi1oZWlnaHQ6IDNyZW07XG4gICAgICAgICAgICBsaW5lLWhlaWdodDogM3JlbTtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgMXJlbTtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcbiAgICAgICAgfVxuICAgIGBdXG59KVxuZXhwb3J0IGNsYXNzIENvbGxhcHNpYmxlSGVhZGVyQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZXZlbnRTZXJ2aWNlOiBDb2xsYXBzaWJsZUV2ZW50U2VydmljZSkgeyB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgY2xpY2soKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLnRvZ2dsZUNvbGxhcHNpYmxlSXRlbSgpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgT25Jbml0LCBBZnRlclZpZXdJbml0LFxuICAgIElucHV0LFxuICAgIFZpZXdDaGlsZHJlblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29sbGFwc2libGVCb2R5Q29tcG9uZW50IH0gZnJvbSAnLi4vY29sbGFwc2libGUtYm9keS9jb2xsYXBzaWJsZS1ib2R5LmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IENvbGxhcHNpYmxlU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2NvbGxhcHNpYmxlLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnY29sbGFwc2libGUtdGFibGUtcm93LWRldGFpbCcsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHRkIGNvbHNwYW49XCIxMDAlXCI+XG4gICAgICAgICAgICA8Y29sbGFwc2libGUtbGlzdC1pdGVtPlxuICAgICAgICAgICAgICAgIDxjb2xsYXBzaWJsZS1ib2R5PlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPC9jb2xsYXBzaWJsZS1ib2R5PlxuICAgICAgICAgICAgPC9jb2xsYXBzaWJsZS1saXN0LWl0ZW0+XG4gICAgICAgIDwvdGQ+XG4gICAgYCxcbiAgICBzdHlsZXM6IFtgXG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRhYmxlLXJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIDpob3N0IGNvbGxhcHNpYmxlLWJvZHksXG4gICAgICAgIDpob3N0IHRkIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cbiAgICBgXVxufSlcbmV4cG9ydCBjbGFzcyBDb2xsYXBzaWJsZVRhYmxlUm93RGV0YWlsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0IHtcbiAgICBzdWJqZWN0OiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbjtcblxuICAgIEBWaWV3Q2hpbGRyZW4oQ29sbGFwc2libGVCb2R5Q29tcG9uZW50KSB2aWV3TGlzdEJvZGllczogQXJyYXk8Q29sbGFwc2libGVCb2R5Q29tcG9uZW50PjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY29sbGFwc2libGVTZXJ2aWNlOiBDb2xsYXBzaWJsZVNlcnZpY2UpIHsgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdC5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3TGlzdEJvZGllcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS50b2dnbGVDb2xsYXBzaWJsZUl0ZW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIC8vIHN0b3JlIGxpc3QgYm9kaWVzIGluICdDb2xsYXBzaWJsZVNlcnZpY2UnXG4gICAgICAgIHRoaXMudmlld0xpc3RCb2RpZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzaWJsZVNlcnZpY2UuYWRkTGlzdEJvZHkoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBJbnB1dCwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lcixcbiAgICBFbGVtZW50UmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRG9tU2FuaXRpemVyIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5cbmltcG9ydCB7IENvbGxhcHNpYmxlVGFibGVSb3dEZXRhaWxDb21wb25lbnQgfSBmcm9tICcuLi9jb2xsYXBzaWJsZS10YWJsZS1yb3ctZGV0YWlsL2NvbGxhcHNpYmxlLXRhYmxlLXJvdy1kZXRhaWwuY29tcG9uZW50JztcbmltcG9ydCB7IENvbGxhcHNpYmxlVGFibGVDb21wb25lbnQgfSBmcm9tICcuLi9jb2xsYXBzaWJsZS10YWJsZS9jb2xsYXBzaWJsZS10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sbGFwc2libGVTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvY29sbGFwc2libGUuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnY29sbGFwc2libGUtdGFibGUtcm93JyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxuICAgIHN0eWxlczogW2BcbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgICAgZGlzcGxheTogdGFibGUtcm93O1xuICAgICAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYmFja2dyb3VuZC1jb2xvciwgY29sb3I7XG4gICAgICAgIH1cbiAgICBgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBFQVNFX09VVF9RVUFEID0gJ2N1YmljLWJlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KSc7XG5cbiAgICBwdWJsaWMgc3RhdGljIERFRkFVTFRfU1RSSVBFRF9PRERfUk9XX0NPTE9SID0gJ3JnYmEoMjQyLDI0MiwyNDIsMC44KSc7XG4gICAgcHVibGljIHN0YXRpYyBERUZBVUxUX1NUUklQRURfRVZFTl9ST1dfQ09MT1IgPSAndHJhbnNwYXJlbnQnO1xuICAgIHB1YmxpYyBzdGF0aWMgREVGQVVMVF9ISUdITElHSFRfUk9XX0NPTE9SID0gJ3JnYmEoMjIyLDIyMiwyMjIsIDAuOCknO1xuICAgIHB1YmxpYyBzdGF0aWMgREVGQVVMVF9BQ1RJVkVfUk9XX0NPTE9SID0gJ3JnYmEoMjEyLDIxMiwyMTIsIDAuOCknO1xuICAgIHB1YmxpYyBzdGF0aWMgREVGQVVMVF9TRUxFQ1RFRF9ST1dfQ09MT1IgPSAncmdiYSgyMTIsMjEyLDIxMiwgMC44KSc7XG5cbiAgICBwdWJsaWMgc3RhdGljIERFRkFVTFRfUk9XX1RFWFRfQ09MT1IgPSAnYmxhY2snO1xuXG4gICAgQElucHV0KCkgZGV0YWlsOiBDb2xsYXBzaWJsZVRhYmxlUm93RGV0YWlsQ29tcG9uZW50O1xuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5jb2xvcicpIHJvd1RleHRDb2xvcjogc3RyaW5nO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yJykgcm93QmFja2dyb3VuZENvbG9yOiBzdHJpbmc7XG5cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnRyYW5zaXRpb24tZHVyYXRpb24nKSBiYWNrZ3JvdW5kVHJhbnNpdGlvbkR1cmF0aW9uID0gJzAuM3MnO1xuICAgIC8vIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlSW5RdWFkXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS50cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicpXG4gICAgYmFja2dyb3VuZFRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IHRoaXMuc2FuaXRpemVyXG4gICAgICAgIC5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUoQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5FQVNFX09VVF9RVUFEKTtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3Muc2VsZWN0ZWQnKSBzZWxlY3RlZDogYm9vbGVhbjtcblxuICAgIGlzSGVhZFJvdyA9IGZhbHNlO1xuICAgIGlzQm9keVJvdyA9IGZhbHNlO1xuICAgIGlzT2RkUm93ID0gZmFsc2U7XG4gICAgaXNFdmVuUm93ID0gZmFsc2U7XG4gICAgaXNQYXJlbnRTdHJpcGVkID0gZmFsc2U7XG4gICAgaXNQYXJlbnRIaWdobGlnaHQgPSBmYWxzZTtcbiAgICBwYXJlbnRBbGxvd3NTZWxlY3QgPSBmYWxzZTtcbiAgICBwYXJlbnRBbGxvd3NTZWxlY3RNdWx0aXBsZVJvd3MgPSBmYWxzZTtcblxuICAgIHBhcmVudFN0cmlwZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHN0cmluZztcbiAgICBwYXJlbnRTdHJpcGVkUm93VGV4dENvbG9yOiBzdHJpbmc7XG4gICAgcGFyZW50SGlnaGxpZ2h0Um93QmFja2dyb3VuZENvbG9yOiBzdHJpbmc7XG4gICAgcGFyZW50SGlnaGxpZ2h0Um93VGV4dENvbG9yOiBzdHJpbmc7XG4gICAgYWN0aXZlUm93QmFja2dyb3VuZENvbG9yOiBzdHJpbmc7XG4gICAgYWN0aXZlUm93VGV4dENvbG9yOiBzdHJpbmc7XG4gICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHN0cmluZztcbiAgICBzZWxlY3RlZFJvd1RleHRDb2xvcjogc3RyaW5nO1xuICAgIHBhcmVudEFsbG93c0Rlc2VsZWN0aW5nUm93cyA9IGZhbHNlO1xuXG4gICAgaW5kZXg6IG51bWJlcjtcblxuICAgIHByaXZhdGUgcGFyZW50Q29sbGFwc2libGVUYWJsZTogQ29sbGFwc2libGVUYWJsZUNvbXBvbmVudDtcbiAgICBwcml2YXRlIHByZXZTZWxlY3RlZFJvd3M6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBkcmFnU2VsZWN0aW9uID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcixcbiAgICAgICAgcHJpdmF0ZSBjb2xsYXBzaWJsZVNlcnZpY2U6IENvbGxhcHNpYmxlU2VydmljZSkgeyB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgZWxlbTogRWxlbWVudCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgdGJvZHk6IEVsZW1lbnQgPSBlbGVtLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmICh0Ym9keS50YWdOYW1lID09PSAnVEJPRFknKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsYXBzaWJsZVRhYmxlUm93czogTm9kZUxpc3RPZjxFbGVtZW50PiA9IHRib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvbGxhcHNpYmxlLXRhYmxlLXJvdycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xsYXBzaWJsZVRhYmxlUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxhcHNpYmxlVGFibGVSb3c6IEVsZW1lbnQgPSBjb2xsYXBzaWJsZVRhYmxlUm93c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2libGVUYWJsZVJvdyA9PT0gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHJpZXZlIHBhcmVudCBDb2xsYXBzaWJsZVRhYmxlQ29tcG9uZW50IHRocm91Z2ggdGhlIENvbGxhcHNpYmxlU2VydmljZVxuICAgICAgICB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUgPSB0aGlzLmNvbGxhcHNpYmxlU2VydmljZS5nZXRDb2xsYXBzaWJsZVRhYmxlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBjb2xsYXBzaWJsZS10YWJsZSBpcyBtYXJrZWQgdG8gc2hvdyBzdHJpcGVkIHRhYmxlXG4gICAgICAgICAgICB0aGlzLmlzUGFyZW50U3RyaXBlZCA9IHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5zdHJpcGVkO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBjb2xsYXBzaWJsZS10YWJsZSBpcyBtYXJrZWQgdG8gaGlnaGxpZ2h0IGN1cnJlbnQgcm93XG4gICAgICAgICAgICB0aGlzLmlzUGFyZW50SGlnaGxpZ2h0ID0gdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50SGlnaGxpZ2h0Um93QmFja2dyb3VuZENvbG9yID0gdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLmhpZ2hsaWdodENvbG9yIHx8XG4gICAgICAgICAgICAgICAgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5ERUZBVUxUX0hJR0hMSUdIVF9ST1dfQ09MT1I7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEhpZ2hsaWdodFJvd1RleHRDb2xvciA9IHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5oaWdobGlnaHRUZXh0Q29sb3IgfHxcbiAgICAgICAgICAgICAgICBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50LkRFRkFVTFRfUk9XX1RFWFRfQ09MT1I7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGNvbGxhcHNpYmxlLXRhYmxlIHNwZWNpZmllcyB0aGUgYWN0aXZlIHJvdyBjb2xvclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuYWN0aXZlQ29sb3IgfHxcbiAgICAgICAgICAgICAgICBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50LkRFRkFVTFRfQUNUSVZFX1JPV19DT0xPUjtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUm93VGV4dENvbG9yID0gdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLmFjdGl2ZVRleHRDb2xvciB8fFxuICAgICAgICAgICAgICAgIENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQuREVGQVVMVF9ST1dfVEVYVF9DT0xPUjtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgY29sbGFwc2libGUtdGFibGUgYWxsb3dzIHNlbGVjdGluZyByb3dzXG4gICAgICAgICAgICB0aGlzLnBhcmVudEFsbG93c1NlbGVjdCA9IHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5zZWxlY3Q7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEFsbG93c1NlbGVjdE11bHRpcGxlUm93cyA9IHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5zZWxlY3RNdWx0aXBsZVJvd3M7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGNvbGxhcHNpYmxlLXRhYmxlIHNwZWNpZmllcyBhIGNvbG9yIGZvciB0aGUgc2VsZWN0ZWQgcm93XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkUm93QmFja2dyb3VuZENvbG9yID0gdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLnNlbGVjdENvbG9yIHx8XG4gICAgICAgICAgICAgICAgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5ERUZBVUxUX1NFTEVDVEVEX1JPV19DT0xPUjtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSb3dUZXh0Q29sb3IgPSB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuc2VsZWN0VGV4dENvbG9yIHx8XG4gICAgICAgICAgICAgICAgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5ERUZBVUxUX1JPV19URVhUX0NPTE9SO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBjb2xsYXBzaWJsZS10YWJsZSBhbGxvd3MgdG8gZGVzZWxlY3Qgcm93c1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRBbGxvd3NEZXNlbGVjdGluZ1Jvd3MgPSB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuYWxsb3dEZXNlbGVjdGluZ1Jvd3MgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLmFsbG93RGVzZWxlY3RpbmdSb3dzIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlUm93KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlUm93KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBlbGVtOiBFbGVtZW50ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgcm93IGlzIGluc2lkZSB0aGUgJ3RoZWFkJ1xuICAgICAgICBjb25zdCB0aCA9IGVsZW0ucXVlcnlTZWxlY3RvcigndGgnKTtcbiAgICAgICAgaWYgKHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFkUm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgcm93IGlzIGluc2lkZSB0aGUgJ3Rib2R5J1xuICAgICAgICBjb25zdCB0ZCA9IGVsZW0ucXVlcnlTZWxlY3RvcigndGQnKTtcbiAgICAgICAgaWYgKHRkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCb2R5Um93ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgcm93IGlzICdvZGQnIG9yICdldmVudCdcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNFdmVuUm93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFN0cmlwZWRSb3dCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuc3RyaXBlZEV2ZW5Db2xvciB8fFxuICAgICAgICAgICAgICAgICAgICBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50LkRFRkFVTFRfU1RSSVBFRF9FVkVOX1JPV19DT0xPUjtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFN0cmlwZWRSb3dUZXh0Q29sb3IgPSB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuc3RyaXBlZEV2ZW5UZXh0Q29sb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5ERUZBVUxUX1JPV19URVhUX0NPTE9SO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT2RkUm93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFN0cmlwZWRSb3dCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuc3RyaXBlZE9kZENvbG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQuREVGQVVMVF9TVFJJUEVEX09ERF9ST1dfQ09MT1I7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTdHJpcGVkUm93VGV4dENvbG9yID0gdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLnN0cmlwZWRPZGRUZXh0Q29sb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5ERUZBVUxUX1JPV19URVhUX0NPTE9SO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMucGFyZW50QWxsb3dzU2VsZWN0ICYmIHRoaXMuc2VsZWN0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93QmFja2dyb3VuZENvbG9yID0gdGhpcy5zZWxlY3RlZFJvd0JhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dUZXh0Q29sb3IgPSB0aGlzLnNlbGVjdGVkUm93VGV4dENvbG9yO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuaXNQYXJlbnRTdHJpcGVkOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0JhY2tncm91bmRDb2xvciA9IHRoaXMucGFyZW50U3RyaXBlZFJvd0JhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dUZXh0Q29sb3IgPSB0aGlzLnBhcmVudFN0cmlwZWRSb3dUZXh0Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0xlZnRNb3VzZUJ1dHRvbihldmVudDogTW91c2VFdmVudCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBidXR0b246IG51bWJlciA9IGV2ZW50LmJ1dHRvbjtcbiAgICAgICAgY29uc3Qgd2hpY2g6IG51bWJlciA9IGV2ZW50Wyd3aGljaCddO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSA8SFRNTEVsZW1lbnQ+KGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50IHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgIGlmIChbJ1RSJywgJ1REJ10uaW5kZXhPZih0YXJnZXQudGFnTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgaWYgKCdidXR0b24nIGluIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbiA9PT0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh3aGljaCB8fCBidXR0b24pID09PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicsIFsnJGV2ZW50J10pXG4gICAgbW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIC8vIGhhbmRsZSBvbmx5IGlmIHRoZSBMZWZ0IG1vdXNlIGJ1dHRvbiBwcmVzc2VkXG4gICAgICAgIC8vIGFuZCB0aGUgcm93IGlzIGEgYm9keSByb3dcbiAgICAgICAgaWYgKHRoaXMuaXNMZWZ0TW91c2VCdXR0b24oZXZlbnQpICYmIHRoaXMuaXNCb2R5Um93KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLm5vVGV4dFNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0JvZHlSb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRBbGxvd3NTZWxlY3QgJiYgIXRoaXMucGFyZW50QWxsb3dzRGVzZWxlY3RpbmdSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldlNlbGVjdGVkUm93cyA9IHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5zZWxlY3RlZFJvd3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5jbGVhclNlbGVjdGVkUm93cygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuZGVzZWxlY3RBbGxSb3dzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucm93QmFja2dyb3VuZENvbG9yID0gdGhpcy5hY3RpdmVSb3dCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dUZXh0Q29sb3IgPSB0aGlzLmFjdGl2ZVJvd1RleHRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNldXAnLCBbJyRldmVudCddKVxuICAgIG1vdXNldXAoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgLy8gaGFuZGxlIG9ubHkgaWYgdGhlIExlZnQgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgLy8gYW5kIHRoZSByb3cgaXMgYSBib2R5IHJvd1xuICAgICAgICBpZiAodGhpcy5pc0xlZnRNb3VzZUJ1dHRvbihldmVudCkgJiYgdGhpcy5pc0JvZHlSb3cpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudEFsbG93c1NlbGVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnRBbGxvd3NEZXNlbGVjdGluZ1Jvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLnNlbGVjdFJvdyh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLnRvZ2dsZVJvd1NlbGVjdGlvbih0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgcm93IHN0YXRlXG4gICAgICAgICAgICB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUudXBkYXRlVGFibGUoKTtcbiAgICAgICAgICAgIC8qc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IGFsbG93cyBzZWxlY3Rpbmcgcm93cyBhbmQgdGhlIHJvdyBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJlbnRBbGxvd3NTZWxlY3QgJiYgdGhpcy5zZWxlY3RlZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnNlbGVjdGVkUm93QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd1RleHRDb2xvciA9IHRoaXMuc2VsZWN0ZWRSb3dUZXh0Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS51cGRhdGVUYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBoaWdobGlnaHRlZFxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5pc1BhcmVudEhpZ2hsaWdodDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnBhcmVudEhpZ2hsaWdodFJvd0JhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dUZXh0Q29sb3IgPSB0aGlzLnBhcmVudEhpZ2hsaWdodFJvd1RleHRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXBlZFxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5pc1BhcmVudFN0cmlwZWQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93QmFja2dyb3VuZENvbG9yID0gdGhpcy5wYXJlbnRTdHJpcGVkUm93QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd1RleHRDb2xvciA9IHRoaXMucGFyZW50U3RyaXBlZFJvd1RleHRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dCYWNrZ3JvdW5kQ29sb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93VGV4dENvbG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgICAvLyBzZWxlY3QgbXVsdGlwbGUgcm93cyB1c2luZyB0aGUgJ1NoaWZ0JyBrZXlcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudEFsbG93c1NlbGVjdCAmJlxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50QWxsb3dzU2VsZWN0TXVsdGlwbGVSb3dzICYmXG4gICAgICAgICAgICAgICAgZXZlbnQgIT0gbnVsbCAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZTZWxlY3RlZFJvd3MgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZTZWxlY3RlZFJvd3MubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuc2VsZWN0ZWRSb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2VTZWxlY3RlZFJvd3MgPSB0aGlzLnByZXZTZWxlY3RlZFJvd3MuY29uY2F0KHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5zZWxlY3RlZFJvd3MpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZVNlbGVjdGVkUm93cy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Um93SW5kZXggPSBNYXRoLm1pbi5hcHBseShudWxsLCByYW5nZVNlbGVjdGVkUm93cyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSb3dJbmRleCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHJhbmdlU2VsZWN0ZWRSb3dzKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuc2VsZWN0Um93cyhmaXJzdFJvd0luZGV4LCBsYXN0Um93SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGRyYWdTZWxlY3Rpb24gZmxhZyB0byBmYWxzZS4gUHJldmVudHMgc2VsZWN0aW9uIGRyYWcgYmVoYXZpb3JcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBmb2N1cyB0aGUgY29sbGFwc2libGUgdGFibGVcbiAgICAgICAgICAgIHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicsIFsnJGV2ZW50J10pXG4gICAgbW91c2VlbnRlcihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICAvLyBoYW5kbGUgb25seSBpZiB0aGUgcm93IGlzIGEgYm9keSByb3dcbiAgICAgICAgaWYgKHRoaXMuaXNCb2R5Um93KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlIGlzIHRyeWluZyB0byBzZWxlY3QgbXVsdGlwbGUgcm93cyBieSBob2xkaW5nIGEgbW91c2UgYnV0dG9uXG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLnBhcmVudEFsbG93c1NlbGVjdCAmJiB0aGlzLnBhcmVudEFsbG93c1NlbGVjdE11bHRpcGxlUm93cyAmJiB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUubW91c2VEb3duSG9sZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDb2xsYXBzaWJsZVRhYmxlLnNlbGVjdFJvdyh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IGFsbG93cyBzZWxlY3Rpbmcgcm93cyBhbmQgdGhlIHJvdyBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJlbnRBbGxvd3NTZWxlY3QgJiYgdGhpcy5zZWxlY3RlZDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuaXNQYXJlbnRIaWdobGlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93QmFja2dyb3VuZENvbG9yID0gdGhpcy5wYXJlbnRIaWdobGlnaHRSb3dCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93VGV4dENvbG9yID0gdGhpcy5wYXJlbnRIaWdobGlnaHRSb3dUZXh0Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScsIFsnJGV2ZW50J10pXG4gICAgbW91c2VsZWF2ZShldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICAvLyBoYW5kbGUgb25seSBpZiB0aGUgcm93IGlzIGEgYm9keSByb3dcbiAgICAgICAgaWYgKHRoaXMuaXNCb2R5Um93KSB7XG4gICAgICAgICAgICAvLyBjaGVjayByb3cgc3RhdGVcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2UgaXMgdHJ5aW5nIHRvIHNlbGVjdCBtdWx0aXBsZSByb3dzIGJ5IGhvbGRpbmcgYSBtb3VzZSBidXR0b25cbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMucGFyZW50QWxsb3dzU2VsZWN0ICYmIHRoaXMucGFyZW50QWxsb3dzU2VsZWN0TXVsdGlwbGVSb3dzICYmIHRoaXMucGFyZW50Q29sbGFwc2libGVUYWJsZS5tb3VzZURvd25Ib2xkOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENvbGxhcHNpYmxlVGFibGUuc2VsZWN0Um93KHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IGFsbG93cyBzZWxlY3Rpbmcgcm93cyBhbmQgdGhlIHJvdyBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJlbnRBbGxvd3NTZWxlY3QgJiYgdGhpcy5zZWxlY3RlZDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXBwZWRcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuaXNQYXJlbnRTdHJpcGVkOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0JhY2tncm91bmRDb2xvciA9IHRoaXMucGFyZW50U3RyaXBlZFJvd0JhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dUZXh0Q29sb3IgPSB0aGlzLnBhcmVudFN0cmlwZWRSb3dUZXh0Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93QmFja2dyb3VuZENvbG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd1RleHRDb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gICAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGV0YWlsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IDxIVE1MRWxlbWVudD4oZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQuY3VycmVudFRhcmdldCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiBbJ1RSJywgJ1REJ10uaW5kZXhPZih0YXJnZXQudGFnTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWlsLnN1YmplY3QubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBPbkluaXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBJbnB1dCwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lcixcbiAgICBFbGVtZW50UmVmLCBDb250ZW50Q2hpbGRyZW5cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQgfSBmcm9tICcuLi9jb2xsYXBzaWJsZS10YWJsZS1yb3cvY29sbGFwc2libGUtdGFibGUtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2xsYXBzaWJsZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jb2xsYXBzaWJsZS5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdjb2xsYXBzaWJsZS10YWJsZScsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgICBzdHlsZXM6IFtgXG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRhYmxlO1xuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgOmhvc3QgdGhlYWQge1xuICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkMGQwZDA7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdCAvZGVlcC8gdGJvZHkgL2RlZXAvIGNvbGxhcHNpYmxlLXRhYmxlLXJvdyB7XG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdCAvZGVlcC8gY29sbGFwc2libGUtdGFibGUtcm93IHRoLFxuICAgICAgICA6aG9zdCAvZGVlcC8gY29sbGFwc2libGUtdGFibGUtcm93IHRkIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdFtib3JkZXJlZD0ndHJ1ZSddIHtcbiAgICAgICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZDBkMGQwO1xuICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2QwZDBkMDtcbiAgICAgICAgICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2QwZDBkMDtcbiAgICAgICAgfVxuXG4gICAgICAgIDpob3N0W2JvcmRlcmVkPSd0cnVlJ10gL2RlZXAvIGNvbGxhcHNpYmxlLXRhYmxlLXJvdyxcbiAgICAgICAgOmhvc3RbYm9yZGVyZWRIb3Jpem9udGFsbHk9J3RydWUnXSAvZGVlcC8gY29sbGFwc2libGUtdGFibGUtcm93IHtcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZDBkMGQwO1xuICAgICAgICB9XG5cbiAgICAgICAgOmhvc3RbYm9yZGVyZWQ9J3RydWUnXSAvZGVlcC8gY29sbGFwc2libGUtdGFibGUtcm93IHRoLFxuICAgICAgICA6aG9zdFtib3JkZXJlZD0ndHJ1ZSddIC9kZWVwLyBjb2xsYXBzaWJsZS10YWJsZS1yb3cgdGQsXG4gICAgICAgIDpob3N0W2JvcmRlcmVkVmVydGljYWxseT0ndHJ1ZSddIC9kZWVwLyBjb2xsYXBzaWJsZS10YWJsZS1yb3cgdGg6bm90KDpsYXN0LWNoaWxkKSxcbiAgICAgICAgOmhvc3RbYm9yZGVyZWRWZXJ0aWNhbGx5PSd0cnVlJ10gL2RlZXAvIGNvbGxhcHNpYmxlLXRhYmxlLXJvdyB0ZDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkMGQwZDA7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdCguY2VudGVyZWQpIC9kZWVwLyAqIHtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIDpob3N0KC5ub1RleHRTZWxlY3QpIC9kZWVwLyBjb2xsYXBzaWJsZS10YWJsZS1yb3cgdGgsXG4gICAgICAgIDpob3N0KC5ub1RleHRTZWxlY3QpIC9kZWVwLyBjb2xsYXBzaWJsZS10YWJsZS1yb3cgdGQge1xuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIH1cbiAgICBgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ29sbGFwc2libGVTZXJ2aWNlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDb2xsYXBzaWJsZVRhYmxlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xuICAgIC8vIGNvbXBvbmVudCBvcHRpb25zXG4gICAgLy9cbiAgICAvLyBtYWtlcyB0aGUgdGFibGUgYm9yZGVyZWRcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5ib3JkZXJlZCcpIGJvcmRlcmVkOiBib29sZWFuO1xuXG4gICAgLy8gbWFrZXMgdGhlIHRhYmxlIGJvcmRlcmVkIGhvcml6b250YWxseSBvbmx5XG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYm9yZGVyZWRIb3Jpem9udGFsbHknKSBib3JkZXJlZEhvcml6b250YWxseTogYm9vbGVhbjtcblxuICAgIC8vIG1ha2VzIHRoZSB0YWJsZSBib3JkZXJlZCB2ZXJ0aWNhbGx5IG9ubHlcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5ib3JkZXJlZFZlcnRpY2FsbHknKSBib3JkZXJlZFZlcnRpY2FsbHk6IGJvb2xlYW47XG5cbiAgICAvLyBtYWtlcyB0aGUgdGFibGUgc3RyaXBlZFxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnN0cmlwZWQnKSBzdHJpcGVkOiBib29sZWFuO1xuXG4gICAgLy8gYSBjb2xvciBvZiBhbiBvZGQgc3RyaXBlZCByb3dcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5zdHJpcGVkT2RkQ29sb3InKSBzdHJpcGVkT2RkQ29sb3I6IHN0cmluZztcblxuICAgIC8vIGEgdGV4dCBjb2xvciBvZiBhbiBvZGQgc3RyaXBlZCByb3dcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5zdHJpcGVkT2RkVGV4dENvbG9yJykgc3RyaXBlZE9kZFRleHRDb2xvcjogc3RyaW5nO1xuXG4gICAgLy8gYSBjb2xvciBvZiBhbiBldmVuIHN0cmlwZWQgcm93XG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuc3RyaXBlZEV2ZW5Db2xvcicpIHN0cmlwZWRFdmVuQ29sb3I6IHN0cmluZztcblxuICAgIC8vIGEgdGV4dCBjb2xvciBvZiBhbiBldmVuIHN0cmlwZWQgcm93XG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuc3RyaXBlZEV2ZW5UZXh0Q29sb3InKSBzdHJpcGVkRXZlblRleHRDb2xvcjogc3RyaW5nO1xuXG4gICAgLy8gaGlnaGxpZ2h0IHRhYmxlIHJvd3Mgb24gbW91c2UgaG92ZXJcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5oaWdobGlnaHQnKSBoaWdobGlnaHQ6IGJvb2xlYW47XG5cbiAgICAvLyBhIGNvbG9yIG9mIGEgaGlnaGxpZ2h0ZWQgcm93XG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaGlnaGxpZ2h0Q29sb3InKSBoaWdobGlnaHRDb2xvcjogc3RyaW5nO1xuXG4gICAgLy8gYSB0ZXh0IGNvbG9yIG9mIGEgaGlnaGxpZ2h0ZWQgcm93XG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaGlnaGxpZ2h0VGV4dENvbG9yJykgaGlnaGxpZ2h0VGV4dENvbG9yOiBzdHJpbmc7XG5cbiAgICAvLyBhIGNvbG9yIG9mIGFuIGFjdGl2ZSByb3dcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hY3RpdmVDb2xvcicpIGFjdGl2ZUNvbG9yOiBzdHJpbmc7XG5cbiAgICAvLyBhIHRleHQgY29sb3Igb2YgYW4gYWN0aXZlIHJvd1xuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFjdGl2ZVRleHRDb2xvcicpIGFjdGl2ZVRleHRDb2xvcjogc3RyaW5nO1xuXG4gICAgLy8gY2VudGVyIGFsaWduIGFsbCB0aGUgdGV4dCBpbiB0aGUgdGFibGVcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuY2VudGVyZWQnKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5jZW50ZXJlZCcpIGNlbnRlcmVkOiBib29sZWFuO1xuXG4gICAgLy8gbWFrZXMgdGhlIHRhYmxlIGhvcml6b250YWxseSBzY3JvbGxhYmxlIG9uIHNtYWxsZXIgc2NyZWVuIHdpZHRoc1xuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJlc3BvbnNpdmUnKSByZXNwb25zaXZlOiBib29sZWFuO1xuXG4gICAgLy8gYWxsb3dzIHRvIHNlbGVjdCByb3dzXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuc2VsZWN0Jykgc2VsZWN0OiBib29sZWFuO1xuXG4gICAgLy8gYWxsb3dzIHRvIHNlbGVjdCBtdWx0aXBsZSByb3dzXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuc2VsZWN0TXVsdGlwbGVSb3dzJykgc2VsZWN0TXVsdGlwbGVSb3dzOiBib29sZWFuO1xuXG4gICAgLy8gYSBjb2xvciBvZiBhIHNlbGVjdGVkIHJvd1xuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnNlbGVjdENvbG9yJykgc2VsZWN0Q29sb3I6IHN0cmluZztcblxuICAgIC8vIGEgdGV4dCBjb2xvciBvZiBhIHNlbGVjdGVkIHJvd1xuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnNlbGVjdFRleHRDb2xvcicpIHNlbGVjdFRleHRDb2xvcjogc3RyaW5nO1xuXG4gICAgLy8gYWxsb3dzIGRlc2VsZWN0aW5nIHNlbGVjdGVkIHJvd3NcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hbGxvd0Rlc2VsZWN0aW5nUm93cycpIGFsbG93RGVzZWxlY3RpbmdSb3dzOiBib29sZWFuO1xuXG4gICAgLy8gYWxsb3dzIG5hdmlnYXRpb24gYmV0d2VlbiB0YWJsZSByb3dzIHVzaW5nIGFycm93IGtleXNcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hbGxvd0tleWJvYXJkTmF2aWdhdGlvbicpXG4gICAgYWxsb3dLZXlib2FyZE5hdmlnYXRpb24gPSB0cnVlO1xuXG4gICAgLy8gZGlzYWJsZXMgdXNlciBzZWxlY3Qgd2l0aGluZyB0aGUgdGFibGVcbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3Mubm9UZXh0U2VsZWN0JylcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIubm9UZXh0U2VsZWN0Jykgbm9UZXh0U2VsZWN0OiBib29sZWFuO1xuXG4gICAgZml4ZWRUYWJsZUhlaWdodCA9ICdhdXRvJztcblxuICAgIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpIHRhYmluZGV4ID0gMDtcblxuICAgIHNlbGVjdGVkUm93czogQXJyYXk8bnVtYmVyPiA9IFtdO1xuXG4gICAgLy8gc3BlY2lmaWVzIGNvbGxhcHNpYmxlIHR5cGUuIENhbiBiZSBlaXRoZXIgJ2FjY29yZGlvbicgb3IgJ2V4cGFuZGFibGUnXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIudHlwZScpIHR5cGU6ICdhY2NvcmRpb24nIHwgJ2V4cGFuZGFibGUnID0gJ2FjY29yZGlvbic7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQpIGNvbGxhcHNpYmxlVGFibGVSb3dzOiBBcnJheTxDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50PjtcblxuICAgIG1vdXNlRG93bkhvbGQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGNvbGxhcHNpYmxlU2VydmljZTogQ29sbGFwc2libGVTZXJ2aWNlKSB7IH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgLy8gdGhpcy51cGRhdGVGaXhlZFRhYmxlSGVpZ2h0KCk7XG4gICAgICAgIC8qXG4gICAgICAgIExPRyhgQ29sbGFwc2libGVUYWJsZUNvbXBvbmVudDo6bmdPbkluaXQoKVxcbmAgK1xuICAgICAgICAgICAgYHRoaXMgPSB7XFxuYCArXG4gICAgICAgICAgICBgYm9yZGVyZWQgPSAke3RoaXMuYm9yZGVyZWR9XFxuYCArXG4gICAgICAgICAgICBgYm9yZGVyZWRIb3Jpem9udGFsbHkgPSAke3RoaXMuYm9yZGVyZWRIb3Jpem9udGFsbHl9XFxuYCArXG4gICAgICAgICAgICBgYm9yZGVyZWRWZXJ0aWNhbGx5ID0gJHt0aGlzLmJvcmRlcmVkVmVydGljYWxseX1cXG5gICtcbiAgICAgICAgICAgIGBzdHJpcGVkID0gJHt0aGlzLnN0cmlwZWR9XFxuYCArXG4gICAgICAgICAgICBgc3RyaXBlZE9kZENvbG9yID0gJHt0aGlzLnN0cmlwZWRPZGRDb2xvcn1cXG5gICtcbiAgICAgICAgICAgIGBzdHJpcGVkRXZlbkNvbG9yID0gJHt0aGlzLnN0cmlwZWRFdmVuQ29sb3J9XFxuYCArXG4gICAgICAgICAgICBgaGlnaGxpZ2h0ID0gJHt0aGlzLmhpZ2hsaWdodH1cXG5gICtcbiAgICAgICAgICAgIGBoaWdobGlnaHRDb2xvciA9ICR7dGhpcy5oaWdobGlnaHRDb2xvcn1cXG5gICtcbiAgICAgICAgICAgIGBoaWdobGlnaHRUZXh0Q29sb3IgPSAke3RoaXMuaGlnaGxpZ2h0VGV4dENvbG9yfVxcbmAgK1xuICAgICAgICAgICAgYGFjdGl2ZUNvbG9yID0gJHt0aGlzLmFjdGl2ZUNvbG9yfVxcbmAgK1xuICAgICAgICAgICAgYGFjdGl2ZVRleHRDb2xvciA9ICR7dGhpcy5hY3RpdmVUZXh0Q29sb3J9XFxuYCArXG4gICAgICAgICAgICBgY2VudGVyZWQgPSAke3RoaXMuY2VudGVyZWR9XFxuYCArXG4gICAgICAgICAgICBgcmVzcG9uc2l2ZSA9ICR7dGhpcy5yZXNwb25zaXZlfVxcbmAgK1xuICAgICAgICAgICAgYHNlbGVjdCA9ICR7dGhpcy5zZWxlY3R9XFxuYCArXG4gICAgICAgICAgICBgc2VsZWN0Q29sb3IgPSAke3RoaXMuc2VsZWN0Q29sb3J9XFxuYCArXG4gICAgICAgICAgICBgc2VsZWN0VGV4dENvbG9yID0gJHt0aGlzLnNlbGVjdFRleHRDb2xvcn1cXG5gICtcbiAgICAgICAgICAgIGBzZWxlY3RNdWx0aXBsZVJvd3MgPSAke3RoaXMuc2VsZWN0TXVsdGlwbGVSb3dzfVxcbmAgK1xuICAgICAgICAgICAgYG5vVGV4dFNlbGVjdCA9ICR7dGhpcy5ub1RleHRTZWxlY3R9XFxuYCArXG4gICAgICAgICAgICBgfWApO1xuICAgICAgICAgICAgKi9cbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzaWJsZVRhYmxlUm93cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpcGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmlwZWRPZGRDb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpcGVkT2RkVGV4dENvbG9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmlwZWRFdmVuQ29sb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaXBlZEV2ZW5UZXh0Q29sb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGFibGUoJ3N0cmlwZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hpZ2hsaWdodCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoaWdobGlnaHRDb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoaWdobGlnaHRUZXh0Q29sb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGFibGUoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWN0aXZlQ29sb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWN0aXZlVGV4dENvbG9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRhYmxlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3RDb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3RUZXh0Q29sb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0TXVsdGlwbGVSb3dzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FsbG93RGVzZWxlY3RpbmdSb3dzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRhYmxlKCdzZWxlY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjb2xsYXBzaWJsZSB0YWJsZSB0eXBlIGluIENvbGxhcHNpYmxlU2VydmljZVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UgPT09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBjaGFuZ2VzLnR5cGUuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNpYmxlU2VydmljZS5zZXRUeXBlKHRoaXMudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGFwc2libGVTZXJ2aWNlLnNldENvbGxhcHNpYmxlVGFibGUodGhpcyk7XG4gICAgfVxuXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIGFkZFNlbGVjdGVkUm93KGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuc2VsZWN0TXVsdGlwbGVSb3dzICYmIHRoaXMuc2VsZWN0ZWRSb3dzLmluZGV4T2YoaW5kZXgpID09PSAtMTpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkUm93cy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkUm93cy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICF0aGlzLnNlbGVjdE11bHRpcGxlUm93czpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkUm93cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RBbGxSb3dzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJvd3MucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJvd3Muc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlU2VsZWN0ZWRSb3coaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFJvd3MuaW5kZXhPZihpbmRleCkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkUm93cy5zcGxpY2UodGhpcy5zZWxlY3RlZFJvd3MuaW5kZXhPZihpbmRleCksIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJTZWxlY3RlZFJvd3MoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRSb3dzID0gW107XG4gICAgfVxuXG4gICAgZGVzZWxlY3RBbGxSb3dzKCkge1xuICAgICAgICB0aGlzLmNvbGxhcHNpYmxlVGFibGVSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIHJvdy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcm93LnVwZGF0ZVJvdygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxlY3RSb3coaW5kZXg6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgaW5kZXggPT09IDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Um93KDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGluZGV4ID09PSB0aGlzLmNvbGxhcHNpYmxlVGFibGVSb3dzLmxlbmd0aDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RSb3codGhpcy5jb2xsYXBzaWJsZVRhYmxlUm93cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAwIDwgaW5kZXggJiYgaW5kZXggPD0gdGhpcy5jb2xsYXBzaWJsZVRhYmxlUm93cy5sZW5ndGggLSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGVkUm93KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzaWJsZVRhYmxlUm93cy5mb3JFYWNoKChyb3csIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RNdWx0aXBsZVJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnVwZGF0ZVJvdygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHNlbGVjdFJvd3MoZmlyc3RSb3dJbmRleDogbnVtYmVyLCBsYXN0Um93SW5kZXg6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RNdWx0aXBsZVJvd3MgJiZcbiAgICAgICAgICAgIDAgPCBmaXJzdFJvd0luZGV4ICYmIGZpcnN0Um93SW5kZXggPCBsYXN0Um93SW5kZXggJiZcbiAgICAgICAgICAgIGxhc3RSb3dJbmRleCA8PSB0aGlzLmNvbGxhcHNpYmxlVGFibGVSb3dzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2libGVUYWJsZVJvd3MuZm9yRWFjaCgocm93LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Um93SW5kZXggPD0gaSAmJiBpIDw9IGxhc3RSb3dJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGVkUm93KGkpO1xuICAgICAgICAgICAgICAgICAgICByb3cuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3cudXBkYXRlUm93KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZVJvd1NlbGVjdGlvbihpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdCAmJlxuICAgICAgICAgICAgMCA8IGluZGV4ICYmIGluZGV4IDw9IHRoaXMuY29sbGFwc2libGVUYWJsZVJvd3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzaWJsZVRhYmxlUm93cy5mb3JFYWNoKChyb3csIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTZWxlY3RlZFJvdyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGVkUm93KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3cuc2VsZWN0ZWQgPSAhcm93LnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICByb3cudXBkYXRlUm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKnVwZGF0ZUZpeGVkVGFibGVIZWlnaHQoKSB7XG4gICAgICAgIHRoaXMuZml4ZWRUYWJsZUhlaWdodCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICBsZXQgZWxlbTogRWxlbWVudCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IHJvd0hlaWdodHMgPSAwO1xuICAgICAgICBpZiAodGhpcy5jb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0qL1xuXG4gICAgdXBkYXRlU3RyaXBlZChyb3c6IENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyaXBlZCAmJiByb3cuaXNCb2R5Um93KSB7XG4gICAgICAgICAgICByb3cuaXNQYXJlbnRTdHJpcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChyb3cuaXNPZGRSb3cpIHtcbiAgICAgICAgICAgICAgICByb3cucGFyZW50U3RyaXBlZFJvd0JhY2tncm91bmRDb2xvciA9IHRoaXMuc3RyaXBlZE9kZENvbG9yIHx8IENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQuREVGQVVMVF9TVFJJUEVEX09ERF9ST1dfQ09MT1I7XG4gICAgICAgICAgICAgICAgcm93LnBhcmVudFN0cmlwZWRSb3dUZXh0Q29sb3IgPSB0aGlzLnN0cmlwZWRPZGRUZXh0Q29sb3IgfHwgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5ERUZBVUxUX1JPV19URVhUX0NPTE9SO1xuICAgICAgICAgICAgICAgIHJvdy5yb3dCYWNrZ3JvdW5kQ29sb3IgPSByb3cucGFyZW50U3RyaXBlZFJvd0JhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICByb3cucm93VGV4dENvbG9yID0gcm93LnBhcmVudFN0cmlwZWRSb3dUZXh0Q29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5wYXJlbnRTdHJpcGVkUm93QmFja2dyb3VuZENvbG9yID0gdGhpcy5zdHJpcGVkRXZlbkNvbG9yIHx8IENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQuREVGQVVMVF9TVFJJUEVEX0VWRU5fUk9XX0NPTE9SO1xuICAgICAgICAgICAgICAgIHJvdy5wYXJlbnRTdHJpcGVkUm93VGV4dENvbG9yID0gdGhpcy5zdHJpcGVkRXZlblRleHRDb2xvciB8fCBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50LkRFRkFVTFRfUk9XX1RFWFRfQ09MT1I7XG4gICAgICAgICAgICAgICAgcm93LnJvd0JhY2tncm91bmRDb2xvciA9IHJvdy5wYXJlbnRTdHJpcGVkUm93QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIHJvdy5yb3dUZXh0Q29sb3IgPSByb3cucGFyZW50U3RyaXBlZFJvd1RleHRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdy5pc1BhcmVudFN0cmlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJvdy5yb3dCYWNrZ3JvdW5kQ29sb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByb3cucm93VGV4dENvbG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGlnaGxpZ2h0KHJvdzogQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICByb3cuaXNQYXJlbnRIaWdobGlnaHQgPSB0aGlzLmhpZ2hsaWdodDtcbiAgICAgICAgcm93LnBhcmVudEhpZ2hsaWdodFJvd0JhY2tncm91bmRDb2xvciA9IHRoaXMuaGlnaGxpZ2h0Q29sb3IgfHwgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5ERUZBVUxUX0hJR0hMSUdIVF9ST1dfQ09MT1I7XG4gICAgICAgIHJvdy5wYXJlbnRIaWdobGlnaHRSb3dUZXh0Q29sb3IgPSB0aGlzLmhpZ2hsaWdodFRleHRDb2xvciB8fCBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50LkRFRkFVTFRfUk9XX1RFWFRfQ09MT1I7XG4gICAgfVxuXG4gICAgdXBkYXRlQWN0aXZlKHJvdzogQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICByb3cuYWN0aXZlUm93QmFja2dyb3VuZENvbG9yID0gdGhpcy5hY3RpdmVDb2xvciB8fCBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50LkRFRkFVTFRfQUNUSVZFX1JPV19DT0xPUjtcbiAgICAgICAgcm93LmFjdGl2ZVJvd1RleHRDb2xvciA9IHRoaXMuYWN0aXZlVGV4dENvbG9yIHx8IENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQuREVGQVVMVF9ST1dfVEVYVF9DT0xPUjtcbiAgICB9XG5cbiAgICB1cGRhdGVTZWxlY3Qocm93OiBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHJvdy5wYXJlbnRBbGxvd3NTZWxlY3QgPSB0aGlzLnNlbGVjdDtcbiAgICAgICAgcm93LnBhcmVudEFsbG93c1NlbGVjdE11bHRpcGxlUm93cyA9IHRoaXMuc2VsZWN0TXVsdGlwbGVSb3dzO1xuICAgICAgICByb3cucGFyZW50QWxsb3dzRGVzZWxlY3RpbmdSb3dzID0gdGhpcy5hbGxvd0Rlc2VsZWN0aW5nUm93cztcbiAgICAgICAgaWYgKHJvdy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgcm93LnNlbGVjdGVkUm93QmFja2dyb3VuZENvbG9yID0gdGhpcy5zZWxlY3RDb2xvciB8fCBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50LkRFRkFVTFRfU0VMRUNURURfUk9XX0NPTE9SO1xuICAgICAgICAgICAgcm93LnNlbGVjdGVkUm93VGV4dENvbG9yID0gdGhpcy5zZWxlY3RUZXh0Q29sb3IgfHwgQ29sbGFwc2libGVUYWJsZVJvd0NvbXBvbmVudC5ERUZBVUxUX1JPV19URVhUX0NPTE9SO1xuICAgICAgICAgICAgcm93LnJvd0JhY2tncm91bmRDb2xvciA9IHJvdy5zZWxlY3RlZFJvd0JhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIHJvdy5yb3dUZXh0Q29sb3IgPSByb3cuc2VsZWN0ZWRSb3dUZXh0Q29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVUYWJsZShjaGFuZ2U/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGFwc2libGVUYWJsZVJvd3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaXBlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgY2hhbmdlcyB0byBlYWNoIG9mIHRoZSBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNpYmxlVGFibGVSb3dzLmZvckVhY2gocm93ID0+IHsgdGhpcy51cGRhdGVTdHJpcGVkKHJvdyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hpZ2hsaWdodCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNpYmxlVGFibGVSb3dzLmZvckVhY2gocm93ID0+IHsgdGhpcy51cGRhdGVIaWdobGlnaHQocm93KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWN0aXZlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2libGVUYWJsZVJvd3MuZm9yRWFjaChyb3cgPT4geyB0aGlzLnVwZGF0ZUFjdGl2ZShyb3cpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzaWJsZVRhYmxlUm93cy5mb3JFYWNoKHJvdyA9PiB7IHRoaXMudXBkYXRlU2VsZWN0KHJvdyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgY2hhbmdlcyB0byBlYWNoIG9mIHRoZSBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzaWJsZVRhYmxlUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RyaXBlZChyb3cpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodChyb3cpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdChyb3cpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZShyb3cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAvLyBzZWxlY3QgYSByb3cgb25seSBpZiAnc2VsZWN0JyBwcm9wZXJ0eSBpcyBzZXQgdG8gJ3RydWUnXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdCAmJiB0aGlzLmFsbG93S2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICBlbnVtIEtleSB7XG4gICAgICAgICAgICAgICAgYXJyb3dVcCA9IDM4LFxuICAgICAgICAgICAgICAgIGFycm93RG93biA9IDQwLFxuICAgICAgICAgICAgICAgIGhvbWUgPSAzNixcbiAgICAgICAgICAgICAgICBlbmQgPSAzNVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICAgICAgY29uc3Qgd2hpY2hLZXkgPSBldmVudFsnd2hpY2gnXTtcbiAgICAgICAgICAgIGlmIChLZXlbd2hpY2hLZXldICE9IG51bGwpIHtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdoaWNoS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5LmFycm93VXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgcHJldmlvdXMgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zZWxlY3RlZFJvd3NbdGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleS5hcnJvd0Rvd246XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgbmV4dCByb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkUm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnNlbGVjdGVkUm93c1t0aGlzLnNlbGVjdGVkUm93cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5LmhvbWU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXkuZW5kOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmNvbGxhcHNpYmxlVGFibGVSb3dzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbFJvd3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFJvdyhpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJylcbiAgICBtb3VzZWRvd24oKSB7XG4gICAgICAgIHRoaXMubW91c2VEb3duSG9sZCA9IHRydWU7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2V1cCcpXG4gICAgbW91c2V1cCgpIHtcbiAgICAgICAgdGhpcy5tb3VzZURvd25Ib2xkID0gZmFsc2U7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUsIE1vZHVsZVdpdGhQcm92aWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IENvbGxhcHNpYmxlTGlzdENvbXBvbmVudCB9IGZyb20gJy4vY29sbGFwc2libGUtbGlzdC9jb2xsYXBzaWJsZS1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2xsYXBzaWJsZUxpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9jb2xsYXBzaWJsZS1saXN0LWl0ZW0vY29sbGFwc2libGUtbGlzdC1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2xsYXBzaWJsZUhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vY29sbGFwc2libGUtaGVhZGVyL2NvbGxhcHNpYmxlLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sbGFwc2libGVCb2R5Q29tcG9uZW50IH0gZnJvbSAnLi9jb2xsYXBzaWJsZS1ib2R5L2NvbGxhcHNpYmxlLWJvZHkuY29tcG9uZW50JztcblxuaW1wb3J0IHsgQ29sbGFwc2libGVUYWJsZUNvbXBvbmVudCB9IGZyb20gJy4vY29sbGFwc2libGUtdGFibGUvY29sbGFwc2libGUtdGFibGUuY29tcG9uZW50JztcbmltcG9ydCB7IENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQgfSBmcm9tICcuL2NvbGxhcHNpYmxlLXRhYmxlLXJvdy9jb2xsYXBzaWJsZS10YWJsZS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7IENvbGxhcHNpYmxlVGFibGVSb3dEZXRhaWxDb21wb25lbnQgfSBmcm9tICcuL2NvbGxhcHNpYmxlLXRhYmxlLXJvdy1kZXRhaWwvY29sbGFwc2libGUtdGFibGUtcm93LWRldGFpbC5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBDb2xsYXBzaWJsZVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2NvbGxhcHNpYmxlLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29sbGFwc2libGVFdmVudFNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2NvbGxhcHNpYmxlLWV2ZW50LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29sbGFwc2libGVBbmltYXRpb25zU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvY29sbGFwc2libGUtYW5pbWF0aW9ucy5zZXJ2aWNlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBDb2xsYXBzaWJsZUxpc3RDb21wb25lbnQsXG4gICAgQ29sbGFwc2libGVMaXN0SXRlbUNvbXBvbmVudCxcbiAgICBDb2xsYXBzaWJsZUhlYWRlckNvbXBvbmVudCxcbiAgICBDb2xsYXBzaWJsZUJvZHlDb21wb25lbnQsXG4gICAgQ29sbGFwc2libGVUYWJsZUNvbXBvbmVudCxcbiAgICBDb2xsYXBzaWJsZVRhYmxlUm93Q29tcG9uZW50LFxuICAgIENvbGxhcHNpYmxlVGFibGVSb3dEZXRhaWxDb21wb25lbnRcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIENvbGxhcHNpYmxlTGlzdENvbXBvbmVudCxcbiAgICBDb2xsYXBzaWJsZUxpc3RJdGVtQ29tcG9uZW50LFxuICAgIENvbGxhcHNpYmxlSGVhZGVyQ29tcG9uZW50LFxuICAgIENvbGxhcHNpYmxlQm9keUNvbXBvbmVudCxcbiAgICBDb2xsYXBzaWJsZVRhYmxlQ29tcG9uZW50LFxuICAgIENvbGxhcHNpYmxlVGFibGVSb3dDb21wb25lbnQsXG4gICAgQ29sbGFwc2libGVUYWJsZVJvd0RldGFpbENvbXBvbmVudFxuICBdLFxuICBwcm92aWRlcnM6IFtcbiAgICBDb2xsYXBzaWJsZVNlcnZpY2UsXG4gICAgQ29sbGFwc2libGVFdmVudFNlcnZpY2UsXG4gICAgQ29sbGFwc2libGVBbmltYXRpb25zU2VydmljZVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIENvbGxhcHNpYmxlTW9kdWxlIHtcbiAgc3RhdGljIGZvclJvb3QoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBDb2xsYXBzaWJsZU1vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW0NvbGxhcHNpYmxlTW9kdWxlXVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ0c2xpYl8xLl9fdmFsdWVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzt1QkFXaUQsSUFBSSxLQUFLLEVBQThCO3NCQUMxQyxJQUFJLEtBQUssRUFBNEI7Ozs7O0lBRS9FLG9DQUFPOzs7SUFBUDtRQUNJLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztLQUNwQjs7Ozs7SUFFRCxvQ0FBTzs7OztJQUFQLFVBQVEsSUFBZ0M7UUFDcEMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7S0FDcEI7Ozs7SUFFRCxnREFBbUI7OztJQUFuQjtRQUNJLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0tBQ2hDOzs7OztJQUVELGdEQUFtQjs7OztJQUFuQixVQUFvQixLQUFnQztRQUNoRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0tBQ2pDOzs7OztJQUVELDBDQUFhOzs7O0lBQWIsVUFBYyxNQUFrQztRQUM1QyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUM3Qjs7Ozs7SUFFRCx3Q0FBVzs7OztJQUFYLFVBQVksSUFBOEI7UUFDdEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDMUI7Ozs7SUFFRCx3Q0FBVzs7O0lBQVg7UUFDSSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLHdCQUF3Qjs7WUFFekMsd0JBQXdCLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztZQUMxQyx3QkFBd0IsQ0FBQyxhQUFhLEdB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